<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>插值与拟合</title>
      <link href="/2022/04/12/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/"/>
      <url>/2022/04/12/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>辩论|林正疆学长《政策辩论》讲座笔记</title>
      <link href="/2022/04/05/%E8%BE%A9%E8%AE%BA-%E6%9E%97%E6%AD%A3%E7%96%86%E5%AD%A6%E9%95%BF%E3%80%8A%E6%94%BF%E7%AD%96%E8%BE%A9%E8%AE%BA%E3%80%8B%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/05/%E8%BE%A9%E8%AE%BA-%E6%9E%97%E6%AD%A3%E7%96%86%E5%AD%A6%E9%95%BF%E3%80%8A%E6%94%BF%E7%AD%96%E8%BE%A9%E8%AE%BA%E3%80%8B%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>政策与我们每个人息息相关，最早政策辩比赛采用奥瑞刚制度，改良自法庭辩论，两者很接近。检察官有举证责任去判定被告有罪（相对于被告去证明自己无罪，即使在被告说假话的情况下），无罪推定，任何人在判决前都被推定无罪；正方相当于检察官。</p></blockquote><h1 id="政策辩论的基本原理"><a href="#政策辩论的基本原理" class="headerlink" title="政策辩论的基本原理"></a>政策辩论的基本原理</h1><p>一、政策辩论的意义</p><p>1.政策辩论是以“政策推行与否”作为主题而进行的辩论活动</p><p>2.政策辩论具有高度厘清社会议题、建议施政方针的功能</p><p>3.政策辩论高度要求数据和举证技术</p><blockquote><p>正方是政府国家的角色，反方质疑政府不会去做 的情况下是无效的</p></blockquote><blockquote><p>很多人会问辩论打完这个政策就会推行吗？不过就是一群人嘴炮，可是在一个政策被广泛的讨论之后，通常以后会在社会中有所印证。</p></blockquote><blockquote><p>正方具有责任去说清楚怎么去实行这个政策</p></blockquote><p>4.所谓“政策”，不限于行政作为，但正方必定是以政策的制定者或推动者自居（通常就是政府），反方则未必如此</p><p>5.政策辩论核心精神在于“达成政策效用”以及“举证以实其说”</p><p>6.政策辩论中，在最大可能范围内，必须将一切得失“数据化”</p><p>二、政策辩论的特色</p><p>1.政策辩论的题目，晚关上必定是“具有可推行”——伴随“制度”的政策</p><p>2.并非所有具备“应然性”题目的外观都是政策辩论</p><p>3.并非任何提到“政策”这个名词的题目，都是政策辩论</p><blockquote><p>只要任何一个辩题的正方必然伴随制度，就是政策辩。“刑责年龄”下降，正方需要提出相应政策，降低到多少岁需要提出。</p><p>“人口宽松和人口紧缩”过于抽象，很多时候可能海关一个态度之类的就可以完成，不属于政策辩</p></blockquote><p>三、政策辩论的基本原则</p><p>1.应然面与实然面之争？【必然涉及实然政策如何实施】</p><p>2.立即马上实行or逐步实行？【台湾“高校自己独立招生”，现在问题多不可实行，正方提出只是这个方向正确，50年左右是一个合理时间。政策应该包括立即马上，那就50年后来讨论要不要实行，（类比法庭辩论捅了一刀，50年后他终究会死，很可笑）；“延后退休年龄”，正方提出应该逐步实行，61岁到62岁后面第5年到65岁，从此之后都是65岁，这样是可以的，第一年就是在延后，只不过是循序渐进】</p><p>3.部分区域施行or全面施行？【“设置弃婴岛”，该不该广泛设定，正方决定先从海南岛开始，原则上是不行，除非特定的题目，比如“废除死刑”，正方不能说是河北省与河南省，“赌博特区”之类的题目是可以，题目语境同意将政策推行在特定区域，否则正方不可以提出在特定区域内推行】</p><p>4.题目欠缺主题时，应如何理解？</p><p>5.民意调查VS强制认可权【不能拿民意调查去压人，（检察官不能用这个去判罪），双方具有强制认可权，谁说的有理，民众就会认可，否则出现有人调查所有人，97%都认同。“该不该废除死刑”，92.7%民众希望不会废除，刑法的修复功能，满足人民的法感，——&gt;导致私刑泛滥，不是拿民意调查证明立场，而是证明某一件事情的存在，进而导向立场。（案件发生后，受访者表示再也不相信台湾的正义，如何期待社会秩序的维持。】</p><p>6.政策辩论的正方与反方</p><p>A.无论单题制或双题制，政策辩论的正方必定违反现状</p><p>B.单题制的反方可以选择：维持现状（享有推定利益）、不涉及新制度之提出而单纯修正现状（据情况享有推定利益）、涉及新制度提出而推行相抗计划（不享有推定利益），三种立场</p><h1 id="政策辩论的思考判断体系"><a href="#政策辩论的思考判断体系" class="headerlink" title="政策辩论的思考判断体系"></a>政策辩论的思考判断体系</h1><p>一、需要性（目的性、提出问题）</p><p>1.现状之下发生了某个问题（问题意识的存在）</p><p>2.问题本身必须具有解决的必要性</p><p>3.问题本质上可以是现状的缺失、损害，也可以只是“现状不够好”</p><blockquote><p> 需要性可以建立在现状没问题但改了可以更好的情况下，延后退休年龄获得经济收益</p></blockquote><p>4.针对正方提出的需要性，反方可以在“承认需要性”的前提之下展开讨论（此时主要讨论焦点将出现在后面提到的根属性、解决力、损益比三部分），也可以“根本单纯否定正方的需要性”，或是“一方面否定正方的需要性，另一方面指出其他的需要性”</p><p>二、根属性</p><p>1.现状之下，之所以发生前述问题，是因为这个辩题的正方没有被实行</p><p>  因果关系的连结？</p><p>  政府作为的不可取代性？</p><p>2.根属性是实战交锋中最容易被忽略的角色</p><p>3.A=B的观念模块下，根属性的攻防基本上只有两种：A≠B or 非A（才会也会）=B</p><p>4.反方承认正方的根属性，必然也同时承认正方的需要性</p><p>5.若反方承认正方的根属性，则讨论将聚焦于解决力（可行性）与损益比</p><p>6.根属性=法庭辩论中“否认被告人有此行为”或“因果关系”的抗辩</p><p>此与“否认有次正义需要实现”或“否认有此行为需要被审批”的需要性抗辩不相同</p><p>三、解决力（制度面的可行性）</p><p>1.正方必违反现状，因此正方必须提出制度并论证其解决力（制度面的可行性）。主义，在政策性辩论中，任何企图逃避解决力的行为，结束谬误</p><p>2.任何制度如果欠缺解决力（可行性），则伴随此制度的政策将毫无价值</p><p>3.反方若为变动现状，则反方享有推定利益，可以单纯地站在批判者的角度去评判正方制度的解决力（可行性）</p><p>4.反方若修正现状（或提出相抗计划），则在修正现状（或相抗计划）范围内，反方不再享有推定利益，必须就修正的部分论证其解决力（可行性)</p><p>5.以法庭辩论为例，解决力的争执似乎“针对已经确定是行为人从事的行为，有误必要对之甲乙论罪判刑”的争执</p><p>四、损益比</p><p>1.损=成本、弊端或损失，益=需要性被满足的具体化程度</p><p>2.除了极少数普世且毫无争议的价值外，任何政策都必须经过损益比的考验</p><p>3.具体化的数字&gt;推论式的论证&gt;诉诸经验的解释&gt;断言式的结论</p><p>4.损益比攻防的要诀之一，在于如何用具体化说明（或形容）己方优势，并淡化成本与弊端</p><p>5.最大且最妥当的利益，就是最大的正义，因此绝大多数人热血沸腾的观念（例如：正义），不能成为损益比的攻防依据</p><h1 id="现行辩论制度下政策辩论的困境"><a href="#现行辩论制度下政策辩论的困境" class="headerlink" title="现行辩论制度下政策辩论的困境"></a>现行辩论制度下政策辩论的困境</h1><p>一、现行辩论制度难以贯彻政策的检证要求</p><p>二、利大于弊、弊大于利，此类题目大量混淆政策辩论的思考体系与评判体系【天然排除需要和根属性】</p><p>三、受限于客观条件不充分，主板单位往往回避政策辩论的基本要求</p>]]></content>
      
      
      
        <tags>
            
            <tag> 辩论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划应用之全局对齐</title>
      <link href="/2022/03/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%A8%E5%B1%80%E5%AF%B9%E9%BD%90/"/>
      <url>/2022/03/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%A8%E5%B1%80%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统习题</title>
      <link href="/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/"/>
      <url>/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="调度与死锁"><a href="#调度与死锁" class="headerlink" title="调度与死锁"></a>调度与死锁</h1><p>1．单项选择题</p><p>（1）在下列调度层次中，所有操作系统中都必须配置的调度层次是____。<br>A．作业调度 B．进程调度 C．交换调度 D．中级调度<br>（2）在分时操作系统中，进程调度经常采用 _____ 算法。<br>A．先来先服务 B．最高优先权<br>C．短进程优先 D．时间片轮转<br>（3）_____ 优先权是在创建进程时确定的，确定之后在整个进程运行期间不再改变。</p><p>A.   作业</p><p>（5）现有 3 个同时到达的作业 J1、J2 和 J3，它们的执行时间分别是 T1、T2 和 T3，<br>且 T1＜T2＜T3。系统按单道方式运行且采用短作业优先算法，则平均周转时间是 _____ 。</p><table><thead><tr><th>A．T1+T2+T3</th><th>B．(T1+T2+T3)/3</th><th></th><th></th></tr></thead><tbody><tr><td>C．(3T1+2T2+T3)/3 D．(T1+2T2+3T3)/3 （6）_____ 是指从作业提交给系统到作业完成的时间间隔。</td><td></td><td></td><td></td></tr><tr><td>A．运行时间</td><td>B．响应时间</td><td>C．等待时间</td><td>D．周转时间</td></tr></tbody></table><p>（7）下述作业调度算法中，________调度算法与作业的估计运行时间有关。</p><table><thead><tr><th>A．先来先服务  C．短作业优先</th><th>B．多级队列 D．时间片轮转</th></tr></thead><tbody><tr><td>（8）采用时间片轮转法进行进程调度是为了_____。</td><td></td></tr><tr><td>A．多个终端都能得到系统的及时响应</td><td>B．先来先服务</td></tr></tbody></table><table><thead><tr><th>C．优先级较高的进程得到及时响应</th><th>D．需要 CPU 最短的进程先做</th><th></th><th></th></tr></thead><tbody><tr><td>（9）假设就绪队列中有 10 个进程，系统将时间片设为 200ms， CPU 进行进程切换要</td><td></td><td></td><td></td></tr><tr><td>花费 10ms。则系统开销所占的比率约为 _____。</td><td></td><td></td><td></td></tr><tr><td>A．l％</td><td>B．5％</td><td>C．10％</td><td>D．20％</td></tr></tbody></table><p>（10）采用资源剥夺法可以解除死锁，还可以采用 _____ 方法解除死锁。</p><table><thead><tr><th>A．执行并行操作  C．拒绝分配新资源</th><th>B．撤消进程 D．修改信号量</th><th></th><th></th></tr></thead><tbody><tr><td>（11）发生死锁的必要条件有四个，要防止死锁的发生，可以通过破坏这四个必要条</td><td></td><td></td><td></td></tr><tr><td>件之一来实现，但破坏 _____ 条件是不太实际的。</td><td></td><td></td><td></td></tr><tr><td>A．互斥</td><td>B．不可抢占</td><td>C．部分分配</td><td>D．循环等待</td></tr></tbody></table><p>（12）资源的有序分配策略可以破坏 ____条件。<br>A．互斥使用资源 B．占有且等待资源<br>C．非抢夺资源 D．循环等待资源</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次分析法|评价类模型</title>
      <link href="/2022/03/21/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95-%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/03/21/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95-%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>建模中最基础的模型之一，主要用于解决评价类问题（哪种方案最好，哪位运动员或者员工表现的更优秀</p></blockquote><h1 id="层次分析法的步骤"><a href="#层次分析法的步骤" class="headerlink" title="层次分析法的步骤"></a>层次分析法的步骤</h1><p>不妨用假期旅游为例，假如有P1，P2，P3 3个旅游胜地供你选择，你会根据诸如景色、费用和居住、饮食、旅途条件等一些准则去反复比较那3个候选地点．首先，你会确定这些准则在你的心目中各占多大比重，如果你经济宽绰、醉心旅游，自然特别看重景色条件，而平素俭朴或手头拮据的人则会优先考虑费用，中老年旅游者还会对居住、饮食等条件寄以较大关注．其次，你会就每一个准则将3个地点进行对比，譬如P1景色最好，P2次之；P2次之；P3居住等条件较好等等．最后，你要将这两个层次的比较判断进行综合，在P1,P2,P3中确定哪个作为最佳地点。</p><p>1.分析系统中各因素之间的关系，建立系统的递阶层次结构</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220321084739746.png" alt="image-20220321084739746"></p><p>2.构造判断矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220321084937805.png" alt="image-20220321084937805"></p><blockquote><p>涉及到社会、经济、人文等因素的决策问题的主要困难在于，这些因素通常不易定量地量测．人们凭自己的经验和知识进行判断，当因素较多时给出的结果往往是不全面和不准确的，如果只是定性的结果，则常常不容易被别人接受．Saaty等人的作法，一是不把所有因素放在一起比较，而是两两相互对比，二是对比时采用相对尺度，以尽可能地减少性质不同的诸因素相互比较的困难，提高准确度．</p></blockquote><p>成对比较矩阵（正互反矩阵）：元素两两之间对比，<br>$$<br>a_{ij}&gt;0,aij=\frac{1}{a_{ij}} \qquad  (i,j=1,2,…,n)        \tag{1}<br>$$<br>A称为成对比较或判断矩阵。满足（1）的矩阵称为正互反矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220321094402537.png" alt="image-20220321094402537"></p><p>如果成对比较是绝对一致的，则应该有$a_{12}.a{23}=a{13}$,但实际上会出现不相等。</p><p>引入一致阵的概念：如果一个正互反矩阵A满足<br>$$<br>a_{ij}.a_{jk}=a_{ik}  \qquad  (i,j=1,2,…,n)  \tag {2}<br>$$<br>则称A为一致阵。</p><blockquote><p>1)n阶正互反矩阵为一致阵—最大特征值$ \lambda_{max}=n$</p><p>2)权向量：当A是一致阵时，$\lambda_{m}=n,a_{ij}=\frac{\omega_{i}}{\omega_{j}}$,设$\omega=(\omega_{i})$是$\lambda_{m}$的标准化特征向量，则$\sum_{\omega_{i}}=1$</p><p>例如：<br>$$<br>A=\left(<br>\begin{matrix}<br>1 &amp; 2 &amp; 6 \<br>1/2 &amp; 1 &amp; 3 \<br>1/6 &amp; 1/3 &amp; 1<br>\end{matrix}<br>\right) \tag{3}<br>$$</p><p>是一致阵，$\lambda_{m}=3,\omega=(0.6,0.3,0.1)’$</p><p>很多情况下A不是一致的，这时仍称$\lambda_{m}$的标准化特征向量为权向量，如：<br>$$<br>A=\left(<br>\begin{matrix}<br>1 &amp; 2 &amp; 6 \<br>1/2 &amp; 1 &amp; 4 \<br>1/6 &amp; 1/4 &amp; 1<br>\end{matrix}<br>\right) \tag{4}<br>$$<br>$\lambda_{m}=3.01$. A不一致。$\omega=(0.588,0.322,0.09)’$</p><p>$A\omega=\lambda\omega$</p></blockquote><p>权重计算：全部一致的要求太苛刻了，Saaty等人给出了在成对比较不一致的情况下计算各因素C1，…,Cn对因素O的权重的方法</p><p>3.计算权重，并进行一致性检验（检验通过权重才能用）</p><p>三种方法计算权重：算术平均法，几何平均法，特征值法；最好三种都用</p><blockquote><p>注：（1）一致矩阵不需要进行一致性检验，只有非一致矩阵的判断矩阵才需要进行一致性检验；（2）在论文写作中，应该先进行一致性检验，通过检验后再计算<br>权重</p></blockquote><p>一致性检验的步骤</p><blockquote><p>成对比较阵通常不是一致阵，但是为了能用它的对应于特征根又的特征向量作为被比较因素的权向量，其不一致程度应在容许范围内．怎样确定这个范围呢? </p></blockquote><blockquote><p>前面已经给出n阶一致阵的特征根是n，在本节第三小节将证明的一个重要定理表明，，I阶正互反阵A的最大特征根$\lambda&gt;n$，而当$\lambda=n$时A是一致阵．</p><p>根据这个定理和$\lambda$连续地依赖于的事实可知，$\lambda$比n大得越多，A的不一致程度越严重，用特征向量作为权向量引起的判断误差越大．因而可以用 $\lambda-n$数值的大小来衡量A的不一致程度．</p></blockquote><p>第一步：计算一致性指标CI<br>$$<br>CI=\frac{\lambda_{max}-n}{n-1}\tag{5}<br>$$<br>第二步：查找对应的平均随机一致性指标RI</p><blockquote><p>计算RI的过程是：对于固定的n，随机地构造正互反阵A，（它的元素$a’_{ij}(i&lt;j)$从1<del>9, 1</del>1/9中随机取值），然后计算A的一致性指标CI，构造相当多的A’，用它们的CI的平均值作为随机一致性指标。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220321090112623.png" alt="image-20220321090112623"></p><p>第三步：计算一致性比例CR<br>$$<br>CR=\frac{CI}{RI}<br>$$<br>如果CR&lt;0.1，则可认为判断矩阵的一致性可以接受，可用其特征向量作为权向量；否则需要对判断矩阵进行修正</p><p>第四步：根据权重矩阵计算得分，并进行排序</p><p>得到第2层（准则层）对第1层（目标层，只有一个因素）的权向量，用同样的方法构造第3层（方案层）对第2层的每一个准则的成对比较矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220322200957261.png" alt="image-20220322200957261"></p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220322201305637.png" alt="image-20220322201305637"></p><p>AHP 的优点<br>1、 系统性 AHP 把研究对象作为一个系统，按照分解、比较判<br>断、综合的思维方式进行决策，成为继机理分析、统计分析之后发展<br>起来的系统分析的重要工具。<br>2、 实用性 AHP 把定性和定量方法结合起来，能处理许多用传<br>统的最优化技术无法着手的实际问题，应用范围很广。同时，这种方<br>法将决策者与决策分析者相互沟通，决策者甚至可以直接应用它，这<br>就增加了决策的有效性。<br>3、 简洁性 具有中等文化程度的人即可了解 AHP 的基本原理和<br>掌握其基本步骤，计算也非常简便，且所得结果简单明确，容易为决<br>策者了解和掌握。<br>AHP 的缺点<br>1、 AHP 只能从原有方案中选优，不能生成新方案。<br>2、 AHP 的比较、判断直到结果都是粗糙的，不适于精度要求很<br>高的问题。 （数据包络法 DEA、逼近理想解排序法 TOPSIS、熵权法、<br>模糊综合评判法等适合精度要求较高的问题）<br>3、从建立层次结构模型到给出成对比较矩阵，人的主观因素的<br>作用很大，这就使得决策结果可能难以为众人接受。当然，采取专家<br>群体判断的办法是克服这个缺点的一种途径。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗词格律</title>
      <link href="/2022/03/20/%E8%AF%97%E8%AF%8D%E6%A0%BC%E5%BE%8B/"/>
      <url>/2022/03/20/%E8%AF%97%E8%AF%8D%E6%A0%BC%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>诗韵和平仄是诗词格律最为重要的两件事。</p></blockquote><h1 id="平仄"><a href="#平仄" class="headerlink" title="平仄"></a>平仄</h1><p>古代有四个声调</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统进程管理</title>
      <link href="/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><blockquote><p>是资源分配的基本单位，也是独立运行的基本单位。为了描述并发程序执行时的特征，引入了进程。</p></blockquote><h2 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><blockquote><p>前趋图是一个有向无循环图，用于描述程序、程序段或语句执行的先后次序。</p><ul><li><p>如果(Pi，Pj)∈→，可以写成Pi→Pj，则称Pi是Pj的直接前趋，Pj是Pi的直接后继。</p></li><li><p>若存在一个序列Pi→Pj→…→Pk，则称Pi是Pk的前趋。</p></li><li><p>在前趋图中，没有前趋的结点称为初始结点，没有后继的结点称为终止结点。 </p></li></ul></blockquote><p><img src="https://user-images.githubusercontent.com/38368052/54079942-2083c880-4321-11e9-8d21-b82bf08edecb.jpg" alt="前驱图例"></p><h3 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h3><blockquote><p>按照某种先后次序来执行。</p><ul><li><p>顺序性：处理机的操作严格按照程序所规定的顺序执行，即每一个操作必须在下一个操作开始之前结束。</p></li><li><p>封闭性：程序一旦开始运行，其执行结果不受外界因素影响。</p></li><li><p>可再现性：只要程序执行时的初始条件和执行环境相同，当程序重复执行时，都将获得相同的结果。</p></li></ul></blockquote><h3 id="程序的并发执行及特点"><a href="#程序的并发执行及特点" class="headerlink" title="程序的并发执行及特点"></a>程序的并发执行及特点</h3><p>程序的并发执行是指若干个程序（或程序段）同时在系统中运行，这些程序（或程序段）的执行在时间上是重叠的，一个程序（或程序段）的执行尚未结束，另一个程序（或程序段）的执行已经开始。</p><blockquote><p>进程1、2、3并发执行。对每个进程而言，其输入、计算和输出这三个操作必须顺序执行。它们之间存在如下先后关系：</p><p>I1先于C1和I2 ， C1先于P1和C2 ， P1先于P2</p><p>I2和C1 ， I3、 C2和P1可以并发。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220316085754492.png" alt="image-20220316085754492" style="zoom: 33%;" /><ol><li><p>间断性：并发程序具有“执行—暂停—-执行”这种间断性的活动规律。</p></li><li><p>失去封闭性：多个程序共享系统中的资源，这些资源的状态将由多个程序来改变，致使程序之间相互影响。</p></li><li><p>不可再现性：在初始条件相同的情况下，程序的执行结果依赖于执行的次序。</p></li></ol><blockquote><p>程序并发执行时可能出现与时间有关的错误。</p><p>进程1：r1=x；      进程2：r2=x；</p><p>​         r1++；           r2++；</p><p>​        x=r1；            x=r2；</p><p>设在两进程运行之前，x的值为0。则两进程运行结束后，x值可为：1,2</p></blockquote><h3 id="程序并发执行的条件"><a href="#程序并发执行的条件" class="headerlink" title="程序并发执行的条件"></a>程序并发执行的条件</h3><p>读集：语句执行期间要引用的变量集合，记为R（Si）={a1，…，am}</p><p>写集：语句执行期间要改变的变量集合，记为W（Si）={b1，…，bn}</p><p><strong>Bernstein条件</strong></p><p>Bernstein条件能保证两个程序段并发执行而不会产生与时间有关的错误：</p><ul><li><p>R (Si) ∩ W (Sj) ={ } 这两条保证</p></li><li><p>R (Sj) ∩ W (Si) ={ } 两次读之间数据不变</p></li><li><p>W (Si) ∩ W (Sj) ={ } 本条保证写操作结果不丢失</p><blockquote><p>考虑下面4条语句：</p><p>  S1：a=x+y      S2：b=z+1</p><p>  S3：c=a-b      S4：d=c+1</p><p>R(S1)={x,y}   R(S2)={z}   R(S3)={a,b}</p><p>  W(S1)={a}    W(S2)={b}   W(S3)={c}</p><p>因R(S1)∩ W(S2)∪R(S2)∩ W(S1)∪W(S1)∩W(S2)={ }，故S1和S2可以并发执行 。 </p><p>因R(S2)∩ W(S3)∪R(S3)∩ W(S2)∪W(S3)∩W(S2)={b}，故S2和S3不能并发执行 。 </p></blockquote></li></ul><p>并发语句的描述方式</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220316091320352.png" alt="image-20220316091320352"></p><h2 id="进程的定义及描述"><a href="#进程的定义及描述" class="headerlink" title="进程的定义及描述"></a>进程的定义及描述</h2><p>特征：</p><ul><li><p>动态性：进程是程序的一次执行过程。动态性还表现为它因创建而产生，因调度而执行，因无资源而暂停，因撤消而消亡。而程序是静态实体。</p></li><li><p>并发性：多个进程实体同时存在于内存中，能在一段时间内同时运行。</p></li><li><p>独立性：在传统OS中，进程是独立运行的基本单位，也是系统分配资源和调度的基本单位。</p></li><li><p>异步性：也叫制约性，进程以各自独立的不可预知的速度向前推进。</p></li><li><p>结构性：进程实体由程序段、数据段及进程控制块组成，又称为进程映像。</p></li></ul><blockquote><p>进程与程序的关系：</p><p>进程是动态概念，程序是静态概念；进程是程序在处理机上的一次执行过程，而程序是指令的集合。</p><p>进程是暂时的，程序是永久的。进程是一个状态变化的过程；程序可以长久保存。</p><p>进程与程序的组成不同。进程的组成包括程序、数据和进程控制块。</p><p>进程与程序是密切相关的。一个程序可以对应多个进程；一个进程可以包括多个程序。</p><p>进程可以创建新进程，而程序不能形成新程序。</p></blockquote><h2 id="进程的状态及转换"><a href="#进程的状态及转换" class="headerlink" title="进程的状态及转换"></a>进程的状态及转换</h2><ol><li><p>就绪状态：进程已获得除处理机以外的所有资源，一旦分配了处理机就可以立即执行。</p></li><li><p>执行状态：又称运行状态。一个进程获得必要的资源并正在处理机上执行。</p></li><li><p>阻塞状态：又称等待状态、睡眠状态。正在执行的进程，由于发生某事件而暂时无法执行下去（如等待输入/输出完成）。这时即使把处理机分配给该进程，它也无法运行。</p></li><li><p>新建状态（new）：进程刚刚建立，但还未进入就绪队列。又称创建状态。</p></li><li><p>终止状态（terminated） ：当一个进程正常或异常结束，操作系统已释放它所占用的资源，但尚未将它撤消时的状态，又称退出状态。</p></li></ol><blockquote><p>大多数状态不可逆转，如等待不能转换为运行。</p><p>状态转换大多为被动进行，但运行→等待是主动的。</p><p>一个进程在一个时刻只能处于上述状态之一。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220314142942221.png" alt="image-20220314142942221"></p><ol start="6"><li>挂起状态：在某些系统中，希望人为将进程挂起使之处于静止状态。</li></ol><blockquote><p>进程挂起的原因有：</p><p>系统故障或功能受到破坏：先挂起，故障消除后再恢复。</p><p>检查中间结果：挂起进程以便检查。</p><p>资源不足：挂起进程以腾出资源。</p><p>内存不足：在外存挂起。</p></blockquote><p><strong>因果变迁</strong>：如果一个状态变化A的发生，会引起另一个状态变化B的发生，则称A、B之间是因果变迁。</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220314144135514.png" alt="image-20220314144135514"></p><p>3→4:当发生变迁 3 时，正在执行的进程从执行状态变为就绪状态，进程调度程序必然会从就绪队列中选取，即发生变迁 4。</p><p>1→3:当前执行进程从执行状态变为阻塞状态，不可能同时又从执行状态变为就绪状态。</p><p>2→4:如果处理机空闲，一旦某个进程发生变迁 2，这意味着有一个进程从阻塞状态变为 就绪状态，因而调度程序就会将就绪队列中的此进程投入运行。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h2 id="互斥的实现方法"><a href="#互斥的实现方法" class="headerlink" title="互斥的实现方法"></a>互斥的实现方法</h2><h2 id="信号量（进程同步机制）"><a href="#信号量（进程同步机制）" class="headerlink" title="信号量（进程同步机制）"></a>信号量（进程同步机制）</h2><h3 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h3><p>信号量由两个成员（s，q）组成，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。又称信号灯。</p><blockquote><p>信号量中的整型变量S表示系统中某类资源的数目。</p><p>当其值大于0时，表示系统中当前可用资源的数目；</p><p>当其值小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。</p></blockquote><p>除信号量的初值外，信号量的值仅能由P操作（又称为wait操作）和V操作（又称为signal操作）改变。</p><p>==P操作==</p><p>设S为一个信号量，P（S）执行时主要完成下述动作：</p><ul><li><p> S＝S－1；</p></li><li><p>if（S＜ 0） {设置进程状态为等待；</p></li></ul><p>​                                     将进程放入信号量等待队列；</p><p>​                                      转调度程序；}</p><p>==V操作==</p><p>V(S)执行时主要完成下述动作：</p><ul><li><p>S＝S＋1；</p></li><li><p>if（S≤0）{将信号量等待队列中的第一个进程移出；</p></li></ul><p>​                                  设置其状态为就绪状态并插入就绪队列；</p><p>​                                   然后再返回原进程继续执行；}</p><blockquote><p>P操作可能阻塞执行进程，而V操作可以唤醒其他进程。</p><p>P、V操作在封锁中断的情况下执行，即一个进程在信号量上操作时，不会有别的进程同时修改该信号量。也就是说P、V操作是原语。</p></blockquote><h3 id="利用信号量实现互斥"><a href="#利用信号量实现互斥" class="headerlink" title="利用信号量实现互斥"></a>利用信号量实现互斥</h3><h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><h3 id="信号量集机制-AND型信号量"><a href="#信号量集机制-AND型信号量" class="headerlink" title="信号量集机制-AND型信号量"></a>信号量集机制-AND型信号量</h3><p>AND型信号量的基本思想是：将进程在整个运行过程中需要的多类资源，一次性地全部分配给进程，待该进程使用完后再一起释放。只要有一个资源未能分配给该进程，其他所有资源也不分配。</p><p>我们称AND型信号量的P原语为SP或Swait， V原语为SV或Ssignal。</p><p>==SP操作== </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SP（S1，S2，…，Sn）   </span><br><span class="line">&#123;  if（S1＞＝1 &amp; S2＞＝1 &amp; … &amp; Sn＞＝1）</span><br><span class="line">       for （i=1; i&lt;= n; i++)  Si= Si-1;</span><br><span class="line">    else</span><br><span class="line">   &#123;将进程插入第一个小于1的信号量等待队列；</span><br><span class="line">     将调用进程的程序计数器置为SP的第一条指令；</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>==SV操作==</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SV（S1，S2，…，Sn ）</span><br><span class="line">&#123;  for （i=1； i&lt;=n; i++)  </span><br><span class="line">   &#123;   Si= Si+1;</span><br><span class="line">       唤醒Si等待队列上的所有进程</span><br><span class="line">       并将它们插入就绪队列；</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般信号量级</p><p>信号量集是AND型信号量的扩充，其基本思想是：在一次原语操作中完成对所有资源的申请，即进程可以一次申请多类资源，每类资源可以申请多个，当某类资源的数量低于其下限值或不能满足进程的申请要求时，则不进行分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SP（S1,t1,d1，S2,t2,d2，…，Sn,tn,dn）</span><br><span class="line">     /*ti为下限值，di为资源申请量*/</span><br><span class="line">&#123;  if S1&gt;=t1 &amp;&amp; S1&gt;=d1 &amp;&amp; … &amp;&amp; Sn&gt;=tn &amp;&amp; Sn&gt;=dn )</span><br><span class="line">     for (i=1 ; i&lt;=n; i++) Si=Si－di；</span><br><span class="line">   else</span><br><span class="line">   &#123; 将进程插入第一个资源数小于ti或di的信号量的等待队列；</span><br><span class="line">      将调用进程的程序计数器PC设置为SP的第一条指令；    &#125;  &#125;</span><br><span class="line">SV（S1,d1，S2,d2，…，Sn,dn ）</span><br><span class="line">&#123;   for（ i=1； i&lt;=n; i++)  </span><br><span class="line">     &#123;  Si=Sｉ＋di；</span><br><span class="line">        唤醒队列Si上的所有进程</span><br><span class="line">        并将它们插入就绪队列；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>信号量级的几种特殊情况</p><blockquote><p>SP（S，d，d）:此时信号量集中只有一个信号量，它每次申请d个资源，当资源数量少于d个时，便不予分配。</p><p>SP（S，1，1）：此时的信号量集已退化为记录型信号量。</p><p>SP（S，1，0）：这是一种很特殊的信号量，可作为一个可控开关。当S≥1时，允许多个进程进入特定区域；当S＝0时，禁止任何进程进入特定区。</p></blockquote><h1 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h1><p>资源有限，需要进行分配管理</p><h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><p>处理机的三级调度：                                            </p><ul><li><p>高级调度-作业调度        外存——&gt;内存（面向作业）</p></li><li><p>中级调度-内存调度         外存——&gt;内存（面向进程）</p></li><li><p>低级调度-进程调度           内存——&gt;CPU</p></li></ul><p>​             <img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220323081523450.png" alt="image-20220323081523450" style="zoom:50%;" /></p><p>1.高级调度-作业</p><p>作业调度又称高级调度、宏观调度或长程调度，其主要任务是按一定的原则从外存上处于后备状态的作业中选择一个或多个作业，给它们分配内存、输入/输出设备等必要的资源，并建立相应的进程（PCB），以使该作业具有获得竞争处理机的权利。</p><p>作业调度的运行频率较低，通常为几分钟一次。</p><p>作业调入时会建立相应的进程，作业调出时才撤销</p><p>2.中级调度</p><p>中级调度又称中程调度或交换调度，其功能是将内存中暂时不用的信息移到外存，以腾出空间给内存中的进程使用，或将需要的信息从外存读入内存。</p><p>引入中程调度的目的是提高内存利用率和系统吞吐量。</p><p>中级调度的运行频率介于两者之间。</p><p>调到外存等待为挂起状态，PCB不会一起调出，而是会常驻内存，以此来监管。</p><p>3.低级调度</p><p>进程调度又称低级调度、微观调度或短程调度，其主要任务是按照某种策略和方法从就绪队列中选取一个进程，将处理机分配给它。</p><p>进程调度的运行频率很高，一般几十毫秒要运行一次。 </p><h2 id="作业状态及转换"><a href="#作业状态及转换" class="headerlink" title="作业状态及转换"></a>作业状态及转换</h2><p>作业从提交到完成要经历四种状态：</p><ul><li><p>提交状态：用户作业由输入设备向系统外存输入时作业所处的状态。</p></li><li><p>后备状态：作业输入到外存后，系统为其建立了作业控制块，并把它插入到后备作业队列中等待调度运行。</p></li><li><p>运行状态：作业在内存中执行。</p></li><li><p>完成状态：作业正常或异常结束，但作业占有的资源还未被系统全部回收。 </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220323082910365.png" alt="image-20220323082910365"></p><h3 id="作业调度的功能"><a href="#作业调度的功能" class="headerlink" title="作业调度的功能"></a>作业调度的功能</h3><p>作业调度程序主要完成以下工作 </p><ul><li><p>记录进入系统的各个作业情况。</p></li><li><p>从后备作业中挑选一些作业投入执行。</p></li><li><p>为被选中的作业做好执行前的准备工作。</p></li><li><p>在作业运行结束或运行过程中因某种原因需要撤离时，作业调度程序还要完成作业的善后处理工作。</p></li></ul><p>进程调度的时机</p><p>n正在运行进程结束</p><p>n运行进程因某种原因阻塞，如P操作、I/O等</p><p>n从系统调用或中断返回时，有进程进入就绪队列且就绪队列为空，或进程优先级高于当前运行进程且为剥夺调度方式</p><p>n时间片用完</p><p>进程调度的方式：</p><p>1.抢占方式</p><p>n抢占方式（剥夺方式）：允许调度程序根据某种原则去停止正在执行的进程，将已分配给该进程的处理机重新分配给其他进程。</p><p>n抢占原则有：优先权、时间片。</p><p>2.</p><p>非抢占方式（非剥夺方式）：一旦将处理机分配给某进程后，便让该进程一直执行，直到该进程完成或发生某事件而进入阻塞状态，才把处理机分配给其他进程。</p><p>时机：进程结束、因某种原因而阻塞、执行同步原语等。</p><p>特点：简单，系统开销小，但无法处理紧急任务。</p><h2 id="调度性能评价"><a href="#调度性能评价" class="headerlink" title="调度性能评价"></a>调度性能评价</h2><ul><li><p>CPU利用率：使CPU尽可能的忙碌</p></li><li><p>吞吐量：单位时间内运行完的进程数</p></li><li><p>周转时间：进程从提交到运行结束的时间间隔</p></li><li><p>等待时间：进程在就绪队列中等待调度的时间总和</p></li><li><p>响应时间：从提交请求到系统首次产生响应所用的时间。</p></li></ul><p>最优准则：</p><ul><li><p><strong>最大的<strong><strong>CPU</strong></strong>利用率</strong> 　</p></li><li><p><strong>最大的吞吐量</strong> 　　　</p></li><li><p><strong>最短的周转时间</strong></p></li><li><p><strong>最短的等待时间</strong></p></li><li><p><strong>最短的响应时间</strong> </p></li></ul><p>周转时间（=完成-到达）</p><p>作业的周转时间是指从作业提交到作业完成之间的时间间隔。</p><p>平均周转时间是指多个作业的周转时间的平均值。ｎ个作业的平均周转时间：</p><p>  T =（T1＋T2＋ … ＋Tn）／n（Ti为作业ｉ的周转时间）</p><p>带权周转时间是指作业周转时间与作业实际运行时间的比。</p><p>平均带权周转时间是指多个作业的带权周转时间的平均值。ｎ个作业的平均带权周转时间：</p><p>W ＝（W1＋W2＋ … ＋Wn）/n（Wi为作业ｉ的带权周转时间）</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h3><p>先请求CPU的进程先分配到CPU</p><p>先来先服务算法既可用于作业调度，也可用于进程调度。</p><p>在作业调度中：从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源，创建进程，然后放入就绪队列。</p><p>进程调度中：从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或因等待某一事件而阻塞时才释放处理机。</p><p>算法简单，易于实现，非抢占式算法，不会导致饥饿</p><p>对长作业有利，但不利于短作业及I/O繁忙型作业。</p><h3 id="最短作业优先调度（SJF）"><a href="#最短作业优先调度（SJF）" class="headerlink" title="最短作业优先调度（SJF）"></a>最短作业优先调度（SJF）</h3><p>n最短作业优先：当CPU空闲时，将它赋予具有最短CPU区间的进程。（已到达且运行时间最短）</p><p>在作业调度中，从后备队列中选择一个或多个估计运行时间最短的作业，将它们调入内存运行。</p><p>在进程调度中，从就绪队列中选择一个估计运行时间最短的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或因等待某一事件而阻塞时才释放处理机。（非抢占式调度算法）</p><p>算法调度性能较好</p><p>但对长作业不利，未考虑作业的紧迫程度，运行时间为估计。</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220323085706803.png" alt="image-20220323085706803"></p><h3 id="最短剩余时间优先调度算法"><a href="#最短剩余时间优先调度算法" class="headerlink" title="最短剩余时间优先调度算法"></a>最短剩余时间优先调度算法</h3><p>SJF算法可以是抢占的或非抢占的。</p><p>抢占SJF调度有时称为最短剩余时间优先调度。</p><p>若到达新进程的CPU区间短于当前运行进程的剩余时间，则它将抢占CPU。</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220323090002123.png" alt="image-20220323090002123"></p><blockquote><p>最短平均周转时间:当一批作业同时到达，最短作业优先调度算法才能获得最短平均周转时间</p><p>设一组作业p1、p2、…、pn，其运行时间为t1、t2、 …、tn，且假定t1&lt;t2&lt; …&lt;tn，则短作业优先调度算法的总周转时间为：</p><p>t1+（t1+t2）+ … +（t1+ … +tn）</p><p>=n*t1+（n-1）t2+ … +tn</p><p>可以证明：若a1≤ a2≤ … ≤ an且b1≤b2≤ … ≤bn，则</p><p>a1bn+a2bn-1 +…+anb1</p><p>≤ a1bi1+a2bi2 +…+anbin</p><p>≤ a1b1+a2b2 +…+anbn</p><p>其中i1、i2、 …、in 是1、2、 …、n的一个排列。</p></blockquote><h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>优先级调度：每个进程都有一个优先级与其关联， CPU分配给具有最高优先级的进程。</p><p>具有相同优先级的进程按FCFS顺序调度。</p><p> 优先级调度算法 </p><ul><li><p>在作业调度中，从后备作业队列中选择若干优先级高的作业调入内存。</p></li><li><p>在进程调度中，将处理机分配给就绪队列中优先级最高的进程。</p></li><li><p>优先级表示进程的重要性及运行优先性，通常用优先数来衡量。在某些系统中，优先数越大优先级越高；而在另一些系统中，优先数越大优先级越小。</p></li></ul><p>按调度方式对优先级调度算法分类</p><p>非抢占式优先级调度算法：系统一旦将处理机分配给就绪队列中优先级最高的进程后，该进程便一直运行下去，直到完成或因发生某事件使该进程放弃处理机时，系统才将处理机分配给另一个更高优先级的进程。</p><p>抢占式优先级调度算法：将处理机分配给优先级最高的进程，使之运行。在进程运行过程中，一旦出现了另一个优先级更高的进程时，进程调度程序就停止原运行进程，而将处理机分配给新出现的高优先级进程。 </p><p>优先级的类型</p><ul><li><p>静态优先级。静态优先级是在创建进程时确定的，确定之后在整个进程运行期间不再改变。</p><p>确定依据有：</p><p>​     进程类型：系统，用户</p><p>​     进程对资源的需求：执行时间，资源数量</p><p>​     用户要求：紧迫程度</p><p>​    特点：简单易行，系统开销小，但不精确。</p></li><li><p>动态优先级。动态优先级是指在创建进程时，根据进程的特点及相关情况确定一个优先级，在进程运行过程中再根据情况的变化调整优先级。</p><p>确定原则有：占用CPU时间，等待时间。</p><p>​     例：优先数=CPU使用时间/2+基本优先数</p><p>​     CPU使用时间衰减函数:</p><p>​     Decay(CPU使用时间)=CPU使用时间/2</p></li></ul><blockquote><p>问题：饥饿，低优先级的进程可能永远得不到运行。</p><p>解决方法：老化，视进程等待时间的延长提高其优先级。</p></blockquote><h3 id="时间片轮转调度（RR）"><a href="#时间片轮转调度（RR）" class="headerlink" title="时间片轮转调度（RR）"></a>时间片轮转调度（RR）</h3><p>每个进程将得到小单位的CPU时间（时间片），通常为10-100毫 秒。时间片用完后，该进程将被抢占并插入就绪队列末尾。</p><p>时间片轮转法：系统将所有就绪进程按到达时间的先后次序排成一个队列，每次调度时把CPU分配给队首进程，并令其执行一个时间片。当时间片用完时，停止该进程的执行，将它送至就绪队列末尾等待下一次执行，然后再把处理机分配给就绪队列中的新队首进程。如此不断循环，直至完成为止。</p><p>设有A、B、C、D、E五个进程，其到达时间分别为0、1、2、3、4，要求运行时间依次为3、6、4、5、2，采用时间片轮转调度算法，当时间片大小为1和4时，试计算其平均周转时间和平均带权周转时间。</p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220323092919089.png" alt="image-20220323092919089" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220323092936790.png" alt="image-20220323092936790" style="zoom:50%;" /><p>时间片大小的选择</p><ul><li><p>若时间片太大，所有进程都能在一个时间片内完成，则时间片轮转算法退化为先来先服务；</p></li><li><p>若时间片太小，则进程调度频繁，系统开销增加。</p></li></ul><p>现代操作系统的时间片一般为10-100ms，上下文切换时间一般少于10us。</p><p>应考虑的因素</p><ul><li><p>系统对响应时间的要求：响应时间=时间片*进程数。进程数一定，则时间片与系统响应时间成正比。</p></li><li><p>就绪队列中的进程数目：时间片与就绪进程数成反比。</p></li><li><p>系统处理能力：人所能承受的响应时间一定，系统速度快则时间片可增长。</p></li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>补充题：设单处理机系统中有n（n&gt;2）个进程，问：</p><ul><li><p>是否总有进程运行？为什么？</p></li><li><p>是否会出现等待队列为空的情况？为什么？</p></li><li><p>是否会出现等待队列为空且无进程运行的情况？为什么？</p></li><li><p>是否会出现就绪队列为空的情况？为什么？</p></li></ul><blockquote><p>不一定总有进程运行，当某一运行中的进程被挂起且其他进程都因各种原因处于阻塞状态，即没有进程处于就绪状态时，不一定总有进程运行。</p></blockquote><blockquote><p>有可能会出现。当有一个进程在运行且其他进程已经处于就绪状态时，可能会出现等待队列为空的情况。</p></blockquote><blockquote><p>存疑</p></blockquote><blockquote><p>有可能，当非运行状态的进程都因各种原因处于阻塞状态而不能变为就绪状态时，会出现就绪状态为空的情况。</p></blockquote><p>1.对进程的管理和控制使用____。</p><p>A. 指令         B. 信号量</p><p>C.原语         D.信箱</p><p>2.分配到必要的资源并获得处理机时的进程状态是____。C</p><p>A. 就绪状态        B.撤消状态</p><p>C. 执行状态          D.阻塞状态</p><p>3.程序的顺序执行通常在 ① 的工作环境中，具有以下特征 ② ；程序的并发执行在 ③ 的工作环境中，具有如下特征 ④ 。</p><p>A.资源共享    B.程序的可再现性 </p><p>C.多道程序    D.单道程序</p><p>4.下列进程状态变化中，____变化是不可能发生的。B</p><p>A.等待→就绪     B.等待→运行 </p><p>C.运行→等待     D.运行→就绪</p><p>5.当____时，进程从执行状态转变为就绪状态。B</p><p>A.等待的事件发生    B.时间片到</p><p>C. 等待某一事件     D.进程被调度程序选中</p><p>6.下面对进程的描述中，错误的是_____。</p><p>A.进程是有生命期的  B. 进程执行需要处理机</p><p>C.进程是指令的集合  D.进程是动态的概念</p><p>7.操作系统通过____对进程进行管理。</p><p>A. JCB     B. PCB</p><p>C. DCT    D. CHCT</p><p>8.下面所述步骤中，____不是创建进程所必需的。</p><p>A.建立一个进程控制块</p><p>B.为进程分配内存</p><p>C. 将进程控制块链入就绪队列</p><p>D.由调度程序为进程分配CPU</p><p>单道批处理系统中，有四个作业，其有关情况如表 4.12 所示。在采用响应比高<br>者优先调度算法时分别计算其平均周转时间 T 和平均带权周转时间 W  </p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220323100640062.png" alt="image-20220323100640062"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Geocart 使用教程</title>
      <link href="/2022/03/11/Geocart-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/03/11/Geocart-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>网上关于Geocart的教程比较少，而软件自带的帮助文档是英文，所以本文主要基于帮助文档进行翻译。</p></blockquote><h1 id="一个示例地图"><a href="#一个示例地图" class="headerlink" title="一个示例地图"></a>一个示例地图</h1><p>创建一个地图：</p><ul><li>从<code>file</code>,选择<code>New</code>创建一个文档</li><li>点击<code>Map</code>,选择<code>New</code></li></ul><p>结果：Geocart将使用正弦投影绘制默认地球</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220311163345127.png" alt="image-20220311163345127"></p><p>编辑地图：</p><ul><li></li><li><p>点击<code>Map</code>——&gt;<code>Tissot indicatrice</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB中的地图投影</title>
      <link href="/2022/03/07/MATLAB%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9B%BE%E6%8A%95%E5%BD%B1/"/>
      <url>/2022/03/07/MATLAB%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9B%BE%E6%8A%95%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>MATLAB</strong>中画地图的四种方法：</p><ul><li><p><strong>m_map地图包</strong></p></li><li><p><strong>geoshow方法</strong></p></li><li><p><strong>mapshow方法</strong></p></li><li><p><strong>简单粗暴的plot方法</strong></p></li></ul></blockquote><h1 id="worldmap"><a href="#worldmap" class="headerlink" title="worldmap"></a>worldmap</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%创建世界地图坐标区域</span></span><br><span class="line">worldmap(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line"><span class="comment">%导入海岸线数据</span></span><br><span class="line">load coastlines</span><br><span class="line"><span class="comment">%绘制海岸线</span></span><br><span class="line">plotm(coastlat,coastlom)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220313125710505.png" alt="image-20220313125710505"></p><p>主要流程：</p><ul><li>绘制地图坐标区域（通过axesm、worldmap、usemap）</li><li>导入数据（通过load或者shaperead）</li><li>通过geoshow、plotm、scatterm绘制图像</li></ul><p>等角横轴圆柱投影；</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">landareas = shaperead(<span class="string">&#x27;landareas.shp&#x27;</span>,<span class="string">&#x27;UseGeoCoords&#x27;</span>,<span class="built_in">true</span>);</span><br><span class="line">axesm (<span class="string">&#x27;mercator&#x27;</span>, <span class="string">&#x27;Frame&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;Grid&#x27;</span>, <span class="string">&#x27;on&#x27;</span>,<span class="string">&#x27;origin&#x27;</span>,[<span class="number">0</span> <span class="number">120</span> <span class="number">0</span>]);</span><br><span class="line">geoshow(landareas,<span class="string">&#x27;FaceColor&#x27;</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">.5</span>],<span class="string">&#x27;EdgeColor&#x27;</span>,[<span class="number">.6</span> <span class="number">.6</span> <span class="number">.6</span>]);</span><br><span class="line">tissot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/939319-20160418212413601-1446589159.png" alt="img"></p><p>shaperead的用法</p><p>用于读取shapefile文件的数据，并将其进行存储</p><p>一个读取shp文件的函数，具体用法可以在帮助文档中找到。这里主要讲一下绘图数据的来源。Toolbox中以数据文件的形式提供了整个地球及其主要区域的通用样本数据，以及一些覆盖小区域的高分辨率文件，如世界城市有以下的格式的文件：</p><p>worldcities.dbf,worldcities.shp,worldcities.shx和worldcities.txt。</p><p>我们可以在matlabroot/toolbox/map/mapdata中找到相关数据。</p><p>axesm函数</p><h1 id="geoshow函数："><a href="#geoshow函数：" class="headerlink" title="geoshow函数："></a>geoshow函数：</h1><p>geoshow是用来显示地图数据的函数<br>geoshow的常用方法：<br>geoshow(lat,lon)直接输入经纬度，将以该经纬度为中心，生成一小片地图<br>geoshow(filename)直接输入地图文件名，生成该地图<br>geoshow(_,Name,Value,)输入相关属性并设定参数，生成所需要的地图。<br>geoshow的常用属性：<br>facecolor：定义了地图表面的颜色，需要输入三个参数且均在0至1之间。如果不写此属性，则默认是黄色。<br> ‘facealpha’,0.0 透明度=0 空心<br>edgecolor：定义了边界的颜色，输入的三个参数值同上。也可以直接像上面代码中写的，直接写颜色：‘black’</p><h2 id="计算地球椭球体的一些参数"><a href="#计算地球椭球体的一些参数" class="headerlink" title="计算地球椭球体的一些参数"></a>计算地球椭球体的一些参数</h2><p><img src="https://images2015.cnblogs.com/blog/939319/201605/939319-20160516162559888-1826121464.png" alt="img"></p><p>angle是输入的角度</p><p>referenceEllipsoid（参考椭球体）函数。和这个函数相似的还有referenceSphere（参考球体）和oblateSpheroid函数，都是关于参考系的设置。函数括号中的参数也很明显，分别是设置为WGS84坐标系，单位是km.在进行地图投影的计算前，设置好所需的参考椭球是必须的。MATLAB中包含了多种参考椭球，可以直接使用，只需要查看函数帮助就可以了。</p><p>rcurve函数。计算各种曲率半径。</p><p>基本用法为：rcurve(propertyName,ellipsoid,lat).       transverse，用来计算卯酉圈曲率半径；meridian，用来计算子午圈曲率半径；parallel，用来计算纬线圈半径。只要接下来输入所用参考椭球和纬度，即可计算出相应的参数。</p><p>rsphere函数。计算地球球体的半径。</p><p>triaxial参数可以计算出平均曲率半径。公式为sqrt(a*b),即几何平均值。此外还包括authalic、euler等参数，具体形式请查看帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> -地图投影 -MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辩论|学习资料</title>
      <link href="/2022/03/04/%E8%BE%A9%E8%AE%BA%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
      <url>/2022/03/04/%E8%BE%A9%E8%AE%BA%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下是我在辩论学习过程中搜集到的学习资源，会不断更新</p></blockquote><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>“辩论赛不是读书人的胜利，但辩论一定是”</p><h2 id="《学会提问》"><a href="#《学会提问》" class="headerlink" title="《学会提问》"></a>《学会提问》</h2><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE.jfif"></p><p>阅读渠道：微信读书；<a href="https://book.douban.com/subject/20428922/">豆瓣链接</a></p><h1 id="影视剧"><a href="#影视剧" class="headerlink" title="影视剧"></a>影视剧</h1><p>影视剧也可以成为很好的学习资料。</p><h2 id="《李狗嗨》"><a href="#《李狗嗨》" class="headerlink" title="《李狗嗨》"></a>《李狗嗨》</h2><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><ul><li><p><a href="https://mp.weixin.qq.com/s/VTVon_SKXjJpLeApkq0DDg">林正疆学长《政策辩论》讲座</a></p></li><li></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="笔记博客文档类"><a href="#笔记博客文档类" class="headerlink" title="笔记博客文档类"></a>笔记博客文档类</h2><ul><li>《满座衣冠似雪》黄执中学长的博客合集</li><li></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>结语：以上的书籍等在网络上都是可以搜索到的，最后一类笔记博客类要是想要学习的话，可以把自己的邮箱留在下面，我看到之后会给你发过去的</p>]]></content>
      
      
      <categories>
          
          <category> 辩论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辩论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于github和hexo搭建个人博客</title>
      <link href="/2022/02/28/%E5%9F%BA%E4%BA%8Egithub%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/02/28/%E5%9F%BA%E4%BA%8Egithub%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>基于github和hexo搭建个人博客</p><blockquote><p>本文为自己搭建个人博客的全记录过程，不断更新。</p></blockquote><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>安装 Git</p><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><h2 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h2><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><p>发布一篇文章</p><p>在xing文件根目录下，进入Git Bash命令窗口，输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;new article&quot;</span></span><br></pre></td></tr></table></figure><p>在博客目录下的/source/_posts文件夹下，就可以看到（new article.md）的文件，进入编辑即可；</p><h1 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h1><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><p>安装插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>添加到<code>_config.yml</code>最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br></pre></td></tr></table></figure><p>在Butterfyl主题配置文件<code>_butterfly.yml</code>文件中找到如下内容修改enable:为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: 搜索文章</span><br><span class="line">    hits_empty: &quot;没找到: $&#123;query&#125; 相关内容捏&quot; # 如果没有查到内容相关内容显示</span><br></pre></td></tr></table></figure><p>效果预览</p><p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/image-20220412120415620.png" alt="image-20220412120415620"></p><h2 id="把hexo源码托管到github"><a href="#把hexo源码托管到github" class="headerlink" title="把hexo源码托管到github"></a>把hexo源码托管到github</h2><p><a href="https://www.jianshu.com/p/8814ce1da7a4">https://www.jianshu.com/p/8814ce1da7a4</a></p><p>根据Hexo搭建步骤搭建完Hexo后，通过Hexo d指令可把生成的文件提交到指定git仓库上，但注意这只是提交的生成后的内容，而对于Hexo本身的源码，以及我们对源码做的修改是没法进行版本管理的，且一旦更换机器，我们便失去了原本生成发布的环境。为了方便对源码进行版本管理，且更换机器环境后可以快速部署我们的博客环境，可根据上面链接操作，把Hexo源码托管在Github Pages的仓库的另一个分支上，此后若更换环境，只需要把该仓库分支chekout下来，并在该仓库本地目录下输入指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://space.bilibili.com/13282871">B站up主卷二兔</a></p><p>（很仔细的新手教程，并且是最新版的安装过程）</p><p><a href="https://butterfly.js.org/posts/21cfbf15/">butterfly安装文档</a></p><p><a href="https://www.drflower.top/posts/5920b38e/">Hexo-Butterfly主题博客搭建记录  无境</a></p><p><a href="https://www.drflower.top/posts/5920b38e/">花桑</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>肆意生长</title>
      <link href="/2021/11/25/%E8%82%86%E6%84%8F%E7%94%9F%E9%95%BF/"/>
      <url>/2021/11/25/%E8%82%86%E6%84%8F%E7%94%9F%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="天才之路必将是孤独痛苦的。"><a href="#天才之路必将是孤独痛苦的。" class="headerlink" title="天才之路必将是孤独痛苦的。"></a>天才之路必将是孤独痛苦的。</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一以贯之的努力，不得懈怠的人生</title>
      <link href="/2021/10/04/%E4%BD%A0%E5%A5%BD%E5%95%8A/"/>
      <url>/2021/10/04/%E4%BD%A0%E5%A5%BD%E5%95%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="天才之路必将是孤独而痛苦的。"><a href="#天才之路必将是孤独而痛苦的。" class="headerlink" title="天才之路必将是孤独而痛苦的。"></a>天才之路必将是孤独而痛苦的。</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/12/hello-world/"/>
      <url>/2021/09/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
