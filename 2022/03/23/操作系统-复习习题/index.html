<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统|复习习题 | 川河杏</title><meta name="keywords" content="操作系统"><meta name="author" content="Apricot,2674608132@qq.com"><meta name="copyright" content="Apricot"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="调度与死锁 1．单项选择题 （1）在下列调度层次中，所有操作系统中都必须配置的调度层次是____。 A．作业调度 B．进程调度 C．交换调度 D．中级调度 （2）在分时操作系统中，进程调度经常采用 _____ 算法。 A．先来先服务 B．最高优先权 C．短进程优先 D．时间片轮转 （3）_____ 优先权是在创建进程时确定的，确定之后在整个进程运行期间不再改变。 A.   作业 （5）现有 3">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统|复习习题">
<meta property="og:url" content="http://example.com/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%8D%E4%B9%A0%E4%B9%A0%E9%A2%98/index.html">
<meta property="og:site_name" content="川河杏">
<meta property="og:description" content="调度与死锁 1．单项选择题 （1）在下列调度层次中，所有操作系统中都必须配置的调度层次是____。 A．作业调度 B．进程调度 C．交换调度 D．中级调度 （2）在分时操作系统中，进程调度经常采用 _____ 算法。 A．先来先服务 B．最高优先权 C．短进程优先 D．时间片轮转 （3）_____ 优先权是在创建进程时确定的，确定之后在整个进程运行期间不再改变。 A.   作业 （5）现有 3">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/v2-9acbd6f7775df18ce8639dd9639aa47a_r.jpg">
<meta property="article:published_time" content="2022-03-23T02:20:08.000Z">
<meta property="article:modified_time" content="2022-05-16T03:29:39.006Z">
<meta property="article:author" content="Apricot">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/v2-9acbd6f7775df18ce8639dd9639aa47a_r.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/v2-9b0cf239b8da02ecddd20ebd3c44c85e_1440w.jpg"><link rel="canonical" href="http://example.com/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%8D%E4%B9%A0%E4%B9%A0%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统|复习习题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-16 11:29:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://z3.ax1x.com/2021/09/19/43pFP0.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/v2-9acbd6f7775df18ce8639dd9639aa47a_r.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">川河杏</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统|复习习题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-23T02:20:08.000Z" title="发表于 2022-03-23 10:20:08">2022-03-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-16T03:29:39.006Z" title="更新于 2022-05-16 11:29:39">2022-05-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统|复习习题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote></blockquote>
<h1>调度与死锁</h1>
<p>1．单项选择题</p>
<p>（1）在下列调度层次中，所有操作系统中都必须配置的调度层次是____。<br>
A．作业调度 B．进程调度 C．交换调度 D．中级调度<br>
（2）在分时操作系统中，进程调度经常采用 _____ 算法。<br>
A．先来先服务 B．最高优先权<br>
C．短进程优先 D．时间片轮转<br>
（3）_____ 优先权是在创建进程时确定的，确定之后在整个进程运行期间不再改变。</p>
<p>A.   作业</p>
<p>（5）现有 3 个同时到达的作业 J1、J2 和 J3，它们的执行时间分别是 T1、T2 和 T3，<br>
且 T1＜T2＜T3。系统按单道方式运行且采用短作业优先算法，则平均周转时间是 _____ 。</p>
<table>
<thead>
<tr>
<th>A．T1+T2+T3</th>
<th>B．(T1+T2+T3)/3</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>C．(3T1+2T2+T3)/3 D．(T1+2T2+3T3)/3 （6）_____ 是指从作业提交给系统到作业完成的时间间隔。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A．运行时间</td>
<td>B．响应时间</td>
<td>C．等待时间</td>
<td>D．周转时间</td>
</tr>
</tbody>
</table>
<p>（7）下述作业调度算法中，________调度算法与作业的估计运行时间有关。</p>
<table>
<thead>
<tr>
<th>A．先来先服务  C．短作业优先</th>
<th>B．多级队列 D．时间片轮转</th>
</tr>
</thead>
<tbody>
<tr>
<td>（8）采用时间片轮转法进行进程调度是为了_____。</td>
<td></td>
</tr>
<tr>
<td>A．多个终端都能得到系统的及时响应</td>
<td>B．先来先服务</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>C．优先级较高的进程得到及时响应</th>
<th>D．需要 CPU 最短的进程先做</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>（9）假设就绪队列中有 10 个进程，系统将时间片设为 200ms， CPU 进行进程切换要</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>花费 10ms。则系统开销所占的比率约为 _____。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A．l％</td>
<td>B．5％</td>
<td>C．10％</td>
<td>D．20％</td>
</tr>
</tbody>
</table>
<p>（10）采用资源剥夺法可以解除死锁，还可以采用 _____ 方法解除死锁。</p>
<table>
<thead>
<tr>
<th>A．执行并行操作  C．拒绝分配新资源</th>
<th>B．撤消进程 D．修改信号量</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>（11）发生死锁的必要条件有四个，要防止死锁的发生，可以通过破坏这四个必要条</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>件之一来实现，但破坏 _____ 条件是不太实际的。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A．互斥</td>
<td>B．不可抢占</td>
<td>C．部分分配</td>
<td>D．循环等待</td>
</tr>
</tbody>
</table>
<p>（12）资源的有序分配策略可以破坏 ____条件。<br>
A．互斥使用资源 B．占有且等待资源<br>
C．非抢夺资源 D．循环等待资源</p>
<p>1.链接分配的一个变种采用 FAT 来链接所有文件的块。它的优点是什么？<br>
2.考虑一个磁盘的文件系统，它的逻辑块和物理块的大小都为512字节。假设每个文件的信息已在内存中。针对每种分配策略（连续、链接和索引），回答这些问题：<br>
a．这个系统的逻辑到物理地址映射是如何实现的？（对于索引分配，假设每个文件总是小于512块长。)<br>
b .如果当前处于逻辑块10（即最后访问的块为块10）并且需要访问逻辑块4，必须从磁盘上读时取多少物理块？<br>
3.考虑一个文件系统采用 inode 来表示文件。磁盘块大小为8KB，磁盘块指针需要4字节。这个文件系统具有12个直接磁盘块，以及一级的、二级的和三级的间接磁盘块。这个文件系统存储文件的最大大小是什么？</p>
<p>1.文件分配表FAT是一个数据结构，用在以链接方式存储文件的系统中，记录磁盘分配和空白磁盘块。在该表中，每个磁盘块都有一个条目，并可按块号来索引，使文件被可靠快速的检索到。</p>
<p>2.a.连续分配：逻辑地址等于物理地址/盘块大小</p>
<p>链接分配：为整个磁盘或磁盘分区设置一个表，每个表项的序号与磁盘块号对应，其中保持文件下一个数据块（逻辑地址）所在的磁盘号。</p>
<p>索引分配：文件前十条逻辑地址依次保持在直接索引快的盘块号上，接下来的一级索引，二级索引，三级索引依次可保持1024，1024 * 1024，1024<em>1024</em>1024条逻辑地址。</p>
<p>b.1 4 2</p>
<p>3.$$8kb / 4b = 2048$$</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>8</mn><mo>∗</mo><mn>12</mn><mo>+</mo><mn>8</mn><mo>∗</mo><mn>2048</mn><mo>+</mo><mn>8</mn><mo>∗</mo><mn>2048</mn><mo>∗</mo><mn>2048</mn><mo>+</mo><mn>8</mn><mo>∗</mo><mn>2048</mn><mo>∗</mo><mn>2048</mn><mo>∗</mo><mn>2048</mn><mo>=</mo><mn>68</mn><mo separator="true">,</mo><mn>753</mn><mo separator="true">,</mo><mn>047</mn><mo separator="true">,</mo><mn>648</mn><mi>k</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">8 * 12 + 8 * 2048 + 8 * 2048 * 2048 + 8 * 2048 * 2048 * 2048 = 68,753,047,648 kb
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2048</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2048</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2048</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2048</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2048</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2048</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">68</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">753</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">047</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">648</span><span class="mord mathnormal">kb</span></span></span></span></span></p>
<p><strong>第3章 处理机调度与死锁习题</strong></p>
<p>三、名词解释</p>
<p><strong>高级调度:</strong> 又称作业调度，用于决定把外存上处于后备队列中的哪些作业调入内存，并为之创建进程，排在就绪对列上。</p>
<p><strong>低级调度:</strong> 又称进程调度，用于选择就绪队列上哪个进程可以获得处理机执行。</p>
<p><strong>中级调度:</strong> 又称对换调度，用于将那些暂时不能运行的进程由内存调至外存，排在挂起对列</p>
<p>中，待这些进程重又具备运行条件，且内存又有空闲，将其重新由外存调入内存，排在就绪</p>
<p>队列中。</p>
<p><strong>死锁</strong>**:** 指在多道程序系统中，多个进程在运行过程中因争夺资源造成的一种僵局。</p>
<p><strong>死锁避免:</strong> 不需事先采用各种限制措施去破坏产生死锁的必要条件，而是在资源的动态分配过程中，用某种方式去防止系统进入不安全状态，从而避免发生死锁。</p>
<p><strong>进程同步:</strong> 程间共同完成一项任务时直接发生相互作用的关系，也就是说，这些具有伙伴关系的进程在执行时间次序上必须遵循确定的规律。</p>
<p><strong>进程互斥:</strong> 逻辑上本来完全独立的若干进程，由于竞争同一个资源而产生的相互制约关系。</p>
<p>四、问答题</p>
<p><strong>1</strong>**、设在单道批处理系统中有四道作业，它们提交的时刻及运行时间如下：**</p>
<table>
<thead>
<tr>
<th><strong>作业号</strong></th>
<th><strong>提交时刻（<strong><strong>h</strong></strong>）</strong></th>
<th><strong>运行时间（<strong><strong>h</strong></strong>）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><strong>8.0</strong></td>
<td><strong>1.0</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>8.5</strong></td>
<td><strong>0.5</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>9.0</strong></td>
<td><strong>0.2</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>9.1</strong></td>
<td><strong>0.1</strong></td>
</tr>
</tbody>
</table>
<p><strong>请分别给出在算法FCFS</strong>**、SJF<strong><strong>和HRN</strong></strong>中这组作业的调度顺序、平周转时间和平均带权周转时间。**</p>
<p>**【**<strong>解答】</strong></p>
<p>FCFS算法调度顺序：1，2，3，4，作业运行情况如下表</p>
<table>
<thead>
<tr>
<th>作业号</th>
<th>开始时间</th>
<th>完成时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8.0</td>
<td>9.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>2</td>
<td>9.0</td>
<td>9.5</td>
<td>1.0</td>
<td>2.0</td>
</tr>
<tr>
<td>3</td>
<td>9.5</td>
<td>9.7</td>
<td>0.7</td>
<td>3.5</td>
</tr>
<tr>
<td>4</td>
<td>9.7</td>
<td>9.8</td>
<td>0.7</td>
<td>7.0</td>
</tr>
</tbody>
</table>
<p>平均周转时间T=(1.0+1.0+0.7+0.7)/4=0.85</p>
<p>平均带权周转时间W=(1.0+2.0+3.5+7.0)/4=3.375</p>
<p>SJF算法调度顺序：1，3，4，2，作业运行情况如下表</p>
<table>
<thead>
<tr>
<th>作业号</th>
<th>开始时间</th>
<th>完成时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8.0</td>
<td>9.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>2</td>
<td>9.3</td>
<td>9.8</td>
<td>1.3</td>
<td>2.6</td>
</tr>
<tr>
<td>3</td>
<td>9.0</td>
<td>9.2</td>
<td>0.2</td>
<td>1.0</td>
</tr>
<tr>
<td>4</td>
<td>9.2</td>
<td>9.3</td>
<td>0.2</td>
<td>2.0</td>
</tr>
</tbody>
</table>
<p>平均周转时间T=(1.0+1.3+0.2+0.2)/4=0.675</p>
<p>平均带权周转时间W=(1.0+2.6+1.0+2.0)/4=1.65</p>
<p>HRN算法调度顺序：1，2，4，3，作业运行情况如下表</p>
<table>
<thead>
<tr>
<th>作业号</th>
<th>开始时间</th>
<th>完成时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8.0</td>
<td>9.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>2</td>
<td>9.0</td>
<td>9.5</td>
<td>1.0</td>
<td>2.0</td>
</tr>
<tr>
<td>3</td>
<td>9.6</td>
<td>9.8</td>
<td>0.8</td>
<td>4.0</td>
</tr>
<tr>
<td>4</td>
<td>9.5</td>
<td>9.6</td>
<td>0.5</td>
<td>5.0</td>
</tr>
</tbody>
</table>
<p>平均周转时间T=(1.0+1.0+0.8+0.5)/4=0.825</p>
<p>平均带权周转时间W=(1.0+2.0+4.0+5.0)/4=3.0</p>
<p><strong>2</strong>**、有一个具有两道作业的批处理系统，作业调度采用短作业优先的调度算法，进程调度采用以优先数为基础的抢占式调度算法，有如下表所示的作业序列，数值越小优先级越高。**</p>
<table>
<thead>
<tr>
<th><strong>作业名</strong></th>
<th><strong>到达时间</strong></th>
<th><strong>运行时间</strong></th>
<th><strong>优先数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td><strong>10:00</strong></td>
<td><strong>40min</strong></td>
<td><strong>5</strong></td>
</tr>
<tr>
<td><strong>B</strong></td>
<td><strong>10:20</strong></td>
<td><strong>30min</strong></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td><strong>C</strong></td>
<td><strong>10:30</strong></td>
<td><strong>50min</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td><strong>D</strong></td>
<td><strong>10:50</strong></td>
<td><strong>20min</strong></td>
<td><strong>6</strong></td>
</tr>
</tbody>
</table>
<p><strong>①</strong> <strong>列出所有作业进入内存的时间和结束时间。</strong></p>
<p><strong>②</strong>   <strong>计算平均周转时间。</strong></p>
<p><strong>【解答】</strong> 每个作业的运行将经历两级调度：作业调度和进程调度。只有当作业装入内存后，方能参与进程调度。每次只能有两道作业进入系统内存。</p>
<p>（1）作业进入内存时间和结束时间如下表</p>
<table>
<thead>
<tr>
<th>作业号</th>
<th>进入内存时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10:00</td>
<td>11:10</td>
</tr>
<tr>
<td>B</td>
<td>10:20</td>
<td>10:50</td>
</tr>
<tr>
<td>C</td>
<td>11:10</td>
<td>12:00</td>
</tr>
<tr>
<td>D</td>
<td>10:50</td>
<td>12:20</td>
</tr>
</tbody>
</table>
<p>（2）各作业执行时的周转时间为：</p>
<p>作业A：70分钟 作业  B：30分钟  作业C：90分钟   作业D：90分钟</p>
<p>作业的平均周转时间T=(70+30+90+90)/4=70分钟。</p>
<p><strong>3</strong>**、假定某计算机系统有R1<strong><strong>和R2</strong></strong>两类可再使用资源，其中R1<strong><strong>有2</strong></strong>个单位，R2<strong><strong>有1</strong></strong>个单位。它们被进程P1<strong><strong>和P2</strong></strong>所共享，且已知两个进程均以如下顺序使用两类资源。–&gt;****申请R1–&gt;****申请R2–&gt;****申请R1–&gt;****释放R1–&gt;****释放R2–&gt;**<strong>释放R1–&gt;</strong></p>
<p><strong>试求出系统运行过程中可能到达的死锁点，并画出死锁点的资源分配图。</strong></p>
<p>答：当两个进程都执行完第1步（都占有了资源R1）时，系统进入不安全状态。这时，无论哪个进程执行完第2步，系统都将进入死锁状态。可能到达的死锁点是：进程P1占有一个单位的R1和一个单位的R2，而进程P2占有一个单位的R1。或者，正好相反。此时系统已无空闲资源，而P1和P2两个进程都不释放自己的资源并申请对方的资源，从而造成死锁。<br>
死锁点的资源分配图（进程—资源图）如图所示。</p>
<p><strong>4</strong>**、**<strong>某系统有同类互斥资源m个，供n个进程共享使用。如果每个进程最多申请x个资源（1≤x≤m），试证明：当n(x-1)+1≤m时，系统不会发生死锁。</strong></p>
<p>**证明：**因为每个进程最多申请x个资源，所以最坏情况是每个进程都得到了（x-1）个资源，并且现在均需申请最后一个资源。此时，系统剩余资源数为m-n(x-1)，于是只要系统中至少还有一个资源可供使用，就可以使这n个进程中某个进程得到其所需要的全部资源，并能够继续执行到完成，归还资源可供其他进程使用。因而不会发生死锁。即只要 m-n(x-1)≥1时，系统就一定不会发生死锁。亦即当n(x-1)+1≤m时，系统不会发生死锁。</p>
<p><strong>5</strong>**、n个进程共享某种资源R（该资源共有m个可分配单位），每个进程一次一个地申请或释放资源单位。假设每个进程对该资源的最大需求量均小于m，且各进程最大需求量之和小于m+n，试证明该系统中不可能发生死锁。**</p>
<p>解：设max（i）表示第i个进程的最大资源需求量，need（i）表示第i个进程还需要的资源量，alloc（i）表示第i个进程已分配的资源量。由题中所给条件可知：</p>
<p><strong>max</strong>**（1****）＋…＋max****（n****）=<strong><strong>（need</strong></strong>（1****）＋…＋need****（n****））＋（alloc****（1****）+<strong><strong>…＋alloc</strong></strong>（n****））****＋n**如果在这个系统中发生了死锁，那么一方面m个资源应该全部分配出去，即</p>
<p>alloc（1）＋…＋alloc（n）= m另一方面所有进程将陷入无限等待状态。由上述两式可得：need（1）＋…＋need（n）上式表示死锁发生后，n个进程还需要的资源量之和小于n，这意味着此刻至少存在一个进程i，need（i）=0，即它已获得了所需要的全部资源。既然该进程已获得了它所需要的全部资源，那么它就能执行完成并释放它占有的资源，这与前面的假设矛盾，从而证明在这个系统中不可能发生死锁。<strong>6</strong>**、下表给出系统某时刻的资源分配情况。**  <strong>资源<strong><strong>进程</strong></strong>Allocation<strong><strong>Need</strong></strong>Available<strong><strong>R1</strong></strong>R2<strong><strong>R3</strong></strong>R1<strong><strong>R2</strong></strong>R3<strong><strong>R1</strong></strong>R2<strong><strong>R3</strong></strong>A<strong><strong>3</strong></strong>1<strong><strong>1</strong></strong>1<strong><strong>0</strong></strong>0<strong><strong>1</strong></strong>2<strong><strong>0</strong></strong>B<strong><strong>0</strong></strong>0<strong><strong>0</strong></strong>0<strong><strong>1</strong></strong>2<strong><strong>C</strong></strong>1<strong><strong>1</strong></strong>0<strong><strong>3</strong></strong>0<strong><strong>0</strong></strong>D<strong><strong>1</strong></strong>0<strong><strong>1</strong></strong>0<strong><strong>1</strong></strong>0<strong><strong>E</strong></strong>0<strong><strong>0</strong></strong>0<strong><strong>2</strong></strong>1<strong><strong>0</strong></strong>试问：（1</strong>**）该状态是否安全？<strong><strong>（2</strong></strong>）若进程B<strong><strong>提出请求RequestB</strong></strong>（0****，1****，0****），系统能否将资源分配给它？**  资源进程AllocationNeedworkWork+ AllocationFinishR1R2R3R1R2R3R1R2R3R1R2R3A311100120431TRUEC110300431541TRUED101010541642TRUEE000210642642TRUEB000012642642TRUE(1)能找到安全序列存在，其中之一为：A-&gt;C-&gt;D-&gt;E-&gt;B，所以该系统处于安全状态。（2）①：RequestB（0，1，0）≤<strong>Need</strong>B（0,1,2）   ②：RequestB（0，1，0）≤<strong>Available</strong>（1,2,0）   ③：假设可将资源分配给B，并修改有关数据：  <strong>资源<strong><strong>进程</strong></strong>Allocation<strong><strong>Need</strong></strong>Available<strong><strong>R1</strong></strong>R2<strong><strong>R3</strong></strong>R1<strong><strong>R2</strong></strong>R3<strong><strong>R1</strong></strong>R2<strong><strong>R3</strong></strong>A<strong><strong>3</strong></strong>1<strong><strong>1</strong></strong>1<strong><strong>0</strong></strong>0<strong><strong>1</strong></strong>1<strong><strong>0</strong></strong>B<strong><strong>0</strong></strong>1<strong><strong>0</strong></strong>0<strong><strong>0</strong></strong>2<strong><strong>C</strong></strong>1<strong><strong>1</strong></strong>0<strong><strong>3</strong></strong>0<strong><strong>0</strong></strong>D<strong><strong>1</strong></strong>0<strong><strong>1</strong></strong>0<strong><strong>1</strong></strong>0<strong><strong>E</strong></strong>0<strong><strong>0</strong></strong>0<strong><strong>2</strong></strong>1****0</strong>进入安全检查，发现任有安全序列存在，其中之一为：D-&gt;A-&gt;C-&gt;E-&gt;B。所以，当进程B提出请求RequestB（0，1，0），系统能将资源分配给它。<strong>7</strong>**、<strong><strong>什么是死锁？产生死锁的原因和必要条件？<strong><strong>死锁**是指在多道程序系统中，多个进程在运行过程中因争夺资源造成的一种僵局。<strong>产生原因：</strong>（1）竞争资源 （2）进程推进顺序不当。**产生的必要条件：<strong>1、互斥条件。进程对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占有。2、请求和保持条件。当进程因请求资源而阻塞时，对已获得的资源保持不放。3、不剥夺条件。进程已获得的资源，在未使用完前，不能被剥夺，只能在使用完时由自己释放。4、环路等待条件。在发生死锁时，必然存在一个进程-资源的环形链，即进程集合{P1，P2，。。。，PN}中的P1等待一个P2占用的资源，P2正在等待一个P3占用的资源，。。。，Pn正在等待已被P1所占用的资源。<strong>8</strong></strong>、<strong><strong>有5</strong></strong>个待运</strong></strong>行的作业为A</strong></strong>，B****，C****，D****，E****，各自估计运行时间为9****，6****，3****，5****，x****。试问采用哪种运行次序使得平均响应时间为最短？<strong><strong>响应时间=<strong><strong>等待时间+<strong><strong>要求服务时间</strong>    <strong>相等</strong>     <strong>周转时间=****结束时间-****到达时间</strong>答：由于短作业优先调度算法会使一组作业的平均周转时间最短，所以：当0＜x＜3时，应该采用的运行顺序为：E, C, D, B, A当3≤x≤5时，应该采用的运行顺序为：C，E，D，B，A当5＜x＜6时，应该采用的运行顺序为：C，D，E，B，A当6≤x≤9时，应该采用的运行顺序为：C，D，B，E，A当9＜x时，应该采用的运行顺序为：C，D，B，A，E**9</strong></strong>、<strong><strong>在操作系统中引入并发可提高系统效率。若有两个程序A</strong></strong>和B</strong></strong>，A</strong><strong>程序执行时所做的工作依次需要用CPU</strong>**：10s****；DEV1****：5s****；CPU****：5s****；DEV2****：10s****；CPU****：10s****。B<strong><strong>程序执行时所做的工作依次需要用DEV1</strong></strong>：10s****；CPU****：10s****；DEV2****：5s****；CPU****：5s****；DEV2****：10s****。请计算在顺序环境和并发环境下执行A<strong><strong>和B</strong></strong>两个程序，CPU****的利用率分别是多少？**答：①在顺序环境下执行A和B两个程序，CPU的利用率是50%    <strong>顺序</strong>，一共用时80s，CPU用时40， 40/80=50%。②在并发环境下执行A和B两个程序，CPU的利用率是89%（假设A程序先执行）<strong>并发</strong>，A：10s(CPU)，5s(DEV1)，5s (Wait)，5s(CPU)，10s(DEV2)，10s(CPU)B：10s(DEV)，10s(CPU)，5s(DEV2)，5s(CPU)，5s (Wait)，10s(DEV2)<br>
用时45s，CPU40s，40/45=8/9=89%</p>
<p>第一次作业</p>
<p>第一题</p>
<p>未增加进程前，共运行4个用户进程，此时</p>
<p>CPU利用率＝1-（80%)^4 = 0.59</p>
<p>若再增加1MB 内存，系统中可同时运行9 个用户进程，此时：</p>
<p>CPU 利用率＝1-（80%)^9 = 0.87</p>
<p>故增加IMB 内存使CPU 的利用率提高了47 % :</p>
<p>第二题</p>
<p>2 一个计算机系统，有一台输入机和一台打印机，现有两道程序投入运行，且程序A 先开始做，程序B 后开始运行。程序A 的运行轨迹为：计算50ms 、打印100ms 、再计算50ms 、打印100ms ，结束。程序B 的运行轨迹为：计算50ms 、输入80ms 、再计算100ms ，结束。试说明（1 ）两道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会等待？( 2 ）程序A 、B 有无等待CPU 的情况？若有，指出发生等待的时刻。</p>
<p>答：画出两道程序并发执行图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/clip_image001.png" alt="在这里插入图片描述"></p>
<p>（1）两道程序运行期间，CPU存在空闲等待，时间为100 至150ms 之间（见图中有色部分）</p>
<p>（2）程序A 无等待现象，但程序B 有等待。程序B 有等待时间段为180rns 至200ms 间（见图中有色部分）</p>
<h2 id="第二次作业">第二次作业</h2>
<p>1.进程 P0 和 P1 的共享变量定义及初值为：<br>
boolean flag[2]; int turn=0;<br>
flag[0]=false;flag[1]=false;进程 P0 和 P1 访问临界资源的类 C 代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void P0 //进程 P0</span><br><span class="line">&#123; while (TRUE)</span><br><span class="line">&#123; flag[0]=TRUE;</span><br><span class="line">turn=1;</span><br><span class="line">wile (flag[1] &amp;&amp; turn==1);</span><br><span class="line">临界区;</span><br><span class="line">flag[0]=FALSE;</span><br><span class="line">&#125; &#125;</span><br><span class="line">void P1 //进程 P1</span><br><span class="line">&#123; while (TRUE)</span><br><span class="line">&#123; flag[1]=TRUE;</span><br><span class="line">turn=0;</span><br><span class="line">while (flag[0] &amp;&amp; turn==0);</span><br><span class="line">临界区;</span><br><span class="line">flag[1]=FALSE;</span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>则并发执行进程 P0 和 P1 时是否存在饥饿现象？ 为什么？</p>
<p>2.有两个并发执行的进程 P1 和 P2， 共享初值为 1 的变量 x， P1 对 x 加 1， P2 对 x 减 1。 加 1和减 1 操作的指令序列分别如下所示。</p>
<p>P1： //加 1 操作</p>
<p>load R1， x //取 x 到寄存器 R1 中</p>
<p>inc R1</p>
<p>store x， R1//将 R1 的内容存入 x</p>
<p>P2： //减 1 操作</p>
<p>Load R2， x</p>
<p>dec R2</p>
<p>store x， R2</p>
<p>两个操作完成后， x 的值 。</p>
<p>3.单处理机系统中， 可并行的是 。</p>
<p>Ⅰ . 进程与进程      Ⅱ . 处理机与设备</p>
<p>III.处理机与通道IV.设备与设备</p>
<p>A. Ⅰ 、 Ⅱ 和Ⅲ   B. Ⅰ 、 Ⅱ 和Ⅳ</p>
<p>C. Ⅰ 、 Ⅲ和Ⅳ    D. Ⅱ 、 Ⅲ和Ⅳ</p>
<p>4.设系统中有 n（n&gt;2） 个进程， 且当前不在执行进程调度程序， 试考虑下述 4 种情况：<br>
1.有 1 个运行进程， n-1 个就绪进程， 没有进程处于等待状态。<br>
2.有 1 个运行进程， 没有就绪进程， n-1 进程处于等待状态。<br>
3.有 1 个运行进程， 有 1 个就绪进程， n-2 进程处于等待状态。                               4.没有运行进程， 有 2 个就绪进程， n 个进程处于等待状态</p>
<p>上述情况中， 不可能发生的情况是_____。</p>
<p>7.使用两个变量i和j分别记录当前的取号值和叫号值，并各自使用一个互斥信号用于对i和j的访问和修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int i=0,j=0;</span><br><span class="line">semaphore mutex_i=1,mutex_j=1;</span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">	//进入面包店</span><br><span class="line">	p(mutex_i);</span><br><span class="line">	//取号i</span><br><span class="line">	i++;</span><br><span class="line">	v(mutex_i);</span><br><span class="line">	//等待叫号i并购买面包</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Seller()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		p(mutex_j);</span><br><span class="line">		if(j&lt;i) //号j已有顾客取走并等待</span><br><span class="line">		&#123;</span><br><span class="line">			//叫号j</span><br><span class="line">			j++;</span><br><span class="line">			v(mutex_j);</span><br><span class="line">			//销售面包</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			v(mutex_j);</span><br><span class="line">			//休息片刻</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.设置空缓冲区的数目，用 empty 表示，其初值为 N，满缓冲单元的数目（即字符数目），用 full 表示，其初值为 0，存在缓存区但未处理的字符数目，用 undeal 表示，其初值为 0，存在缓存区且已处理的字符数目，用 dealed 表示，其初值为 0，还设置一个互斥信号量 mutex，其初值为 1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">semaphore full=0;              </span><br><span class="line">semaphore empty=N;              </span><br><span class="line">semaphore undeal=0;             </span><br><span class="line">semaphore dealed=0;             </span><br><span class="line">semaphore mutex=1;              </span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		R();</span><br><span class="line">		M();</span><br><span class="line">		P();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br><span class="line">R()</span><br><span class="line">&#123;</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		读一个字符;</span><br><span class="line">		P(empty);</span><br><span class="line">		P(mutex);</span><br><span class="line">		将一个字符送入缓冲区;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(undeal)</span><br><span class="line">		V(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">M()</span><br><span class="line">&#123;</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		P(undeal);</span><br><span class="line">		P(mutex);</span><br><span class="line">		处理字符;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(dealed);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">P()</span><br><span class="line">&#123;</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		P(full)</span><br><span class="line">		P(dealed);</span><br><span class="line">		P(mutex);</span><br><span class="line">		从缓冲区中取一个字符;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(empty);</span><br><span class="line">		打印一个字符;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>12.设置一个学生进程用来申请进入机房和申请教师检查，一个教师进程用来检查一组学生是否完成并进行检查，一 个门卫进程用来检查一组两个学生是否到齐和检查机房是否有两台计算机。信号量student表示是否有学生；computer表示当前可用的计算机的数量；enter是机房的准入通道；finish表示是否有学生完成了实习；check是老师时候检查完一组学生。初始情况下，除了computer设为2m, 其余都应该是0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">semaphore student=0;</span><br><span class="line">semaphore computer=2m;</span><br><span class="line">semaphore enter=0;</span><br><span class="line">semaphore finish=0;</span><br><span class="line">semaphore check=0;</span><br><span class="line"></span><br><span class="line">//学生进程</span><br><span class="line">Student() &#123;</span><br><span class="line">      </span><br><span class="line">    while(1) &#123;</span><br><span class="line">     </span><br><span class="line">        V(student);  //有学生到达</span><br><span class="line">        P(computer); //获取一台计算机</span><br><span class="line">        P(enter);    //申请进入</span><br><span class="line">        do(); //实习</span><br><span class="line">        V(finish);   //完成实习</span><br><span class="line">        P(check);     //申请检查</span><br><span class="line">        V(computer); //释放计算机</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//老师进程</span><br><span class="line">Teacher() &#123;</span><br><span class="line">     </span><br><span class="line">    while(1) &#123;</span><br><span class="line">     </span><br><span class="line">        P(finsh);    //等待学生实习结束</span><br><span class="line">        P(finsh);    //等待另一个学生实习结束</span><br><span class="line">        check(); //检查</span><br><span class="line">        V(check);     //允许学生离开</span><br><span class="line">        V(check);     //允许另一个学生离开</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//门卫进程</span><br><span class="line">Guard() &#123;</span><br><span class="line">     </span><br><span class="line">    while(1) &#123;</span><br><span class="line">     </span><br><span class="line">        P(student);   //等待一名学生</span><br><span class="line">        P(student);   //等待另一名学生</span><br><span class="line">        P(computer);  //申请一台计算机</span><br><span class="line">        P(computer);  //申请另一台计算机</span><br><span class="line">        V(enter);     //允许学生进入</span><br><span class="line">        V(enter);     //允许另一名学生进入</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol start="14">
<li></li>
</ol>
<p>解:三个学徒编号为0~2，设置三个信号量，用数组a表示，初值均为0，桌面作为临界区为互斥操作设置一个信号量mutex，其初值为1。对应的同步描述如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Semaphore a[3]=[0,0,0];//设a[0]代表学徒0，a[1]代表学徒1， a[2]代表学徒2</span><br><span class="line">Semaphore mutex=1;</span><br><span class="line">main()</span><br><span class="line">&#123;      Cobegin</span><br><span class="line">       sf();xt(O);xt(1);xt(2);</span><br><span class="line">       Coend</span><br><span class="line"> &#125;</span><br><span class="line">sf()    //师傅进程</span><br><span class="line">&#123;   while (true)</span><br><span class="line">   &#123;   i=rand()%3;</span><br><span class="line">       j=rand()%3;</span><br><span class="line">       P(mutex);</span><br><span class="line">       放两个零件到桌面;</span><br><span class="line">       if (i!=j)</span><br><span class="line">       &#123;    if (i==0 &amp;&amp; j==1) V(a[2]);</span><br><span class="line">            else if (i==1 &amp;&amp; j==2) V(a[o]);</span><br><span class="line">            eles V(a[1]);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">xt(i)   //学徒i进程( i=1,1,2)</span><br><span class="line">&#123;    while (true) ;</span><br><span class="line">     &#123;   P(a[i]);</span><br><span class="line">         取两个零件组装产品;</span><br><span class="line">         V(mutex);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、</p>
<p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/QQ%E5%9B%BE%E7%89%8720220419211240.jpg" alt=""></p>
<p>（1）Job1 从投入到运行完成需110ms , Job2 从投入到运行完成需90ms , Job3 从投入到运行完成需110ms.</p>
<p>（2）CPU 空闲时间段共有30ms ，所以CPU 利用率为（110-30）/110 = 72.7 ％。</p>
<p>（3）设备I1 空闲时间段有30ms,故I1的利用率为 (110-30)/l10 = 72 . 7 ％。<br>
设备I2 空闲时间段有20ms，故I2的利用率为(110-20) / 110 = 81.8 ％。</p>
<p>9、</p>
<p>（1）因为存在安全序列，所以此时系统安全。</p>
<p>（2）若满足进程B的请求，则可用资源变为&lt;1，1，0&gt;，此时系统存在安全序列，D-&gt;A-&gt;C-&gt;E-&gt;B，所以能分配。</p>
<p>（3）若满足进程E的请求，则可用资源变为&lt;1，1，0&gt;，此时系统存在安全序列，所以能分配。</p>
<p>10、</p>
<table>
<thead>
<tr>
<th></th>
<th>已占有</th>
<th>还需要</th>
<th>剩余资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>25</td>
<td>45</td>
<td>40</td>
</tr>
<tr>
<td>P2</td>
<td>40</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>45</td>
<td>15</td>
<td></td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>60</td>
<td></td>
</tr>
</tbody>
</table>
<p>(1)由于系统目前还有40个单元，P4进程到达，把25个单元分给它。这时系统还余15个单元,可把15个单元分给P3，它执行完后会释放60个单元。于是可供P1(还要45个单元),P2(还要20个单元)，P4(还要35个单元)任何一个执行，安全序列为:<br>
P1, P2, P3,P4；P3,P1，P2,P4</p>
<p>(2)P4进程到达，P4最大需求60,最初请求35。如果把35个单元分给P4，系统还余5<br>
个单元,不再能满足任何一个进程的需求,系统进入不安全状态·</p>
<p>12、</p>
<p>设每个进程对共享资源的最大需求量为x(0＜x≤m)，假设系统发生死锁，每个进程都得到了(x-1)个资源i并且都需申请最后一个资源。这时系统剩余资源数为：m-n(x-1)。</p>
<p>当m-m(x-1)≥1时系统不会发生死锁。进而可得系统中所有进程的最大需求量之和n·x≤(m+n-1)时系统不会发生死锁，而进程最大需求量之和小于m+n，所以，不会发生死锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/QQ%E5%9B%BE%E7%89%8720220420141330.jpg" alt=""></p>
<p>课堂作业：</p>
<table>
<thead>
<tr>
<th></th>
<th>已占有</th>
<th>还需要</th>
<th>剩余资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>25</td>
<td>45</td>
<td>40</td>
</tr>
<tr>
<td>P2</td>
<td>40</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>45</td>
<td>15</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>60</td>
<td></td>
</tr>
</tbody>
</table>
<p>（5）一个 32 位地址的计算机系统使用二级页表，虚地址被分为 9 位顶级页表，11 位二级页表和偏移。试问：页表长度是多少？虚地址空间共有多少个页面？</p>
<p>（6）某计算机有缓存、内存、辅存来实现虚拟存储器。如果数据在缓存中，访问它需要 Ans；如果在内存但不在缓存，需要 Bns 将其装入缓存，然后才能访问；如果不在内存而在辅存，需要 Cns 将其读入内存，然后，用 Bns 再读入缓存，然后才能访问。假设缓存命中率为（n-1）/n，内存命中率为（m-1）/m，则数据平均访问时间是多少？</p>
<p>（7）一台机器有 48 位虚地址和 32 位物理地址，若页长为 8KB，问页表共有多少<br>
个页表项?如果设计一个反置页表，则有多少个页表项？</p>
<p>（8）有两台计算机 P1 和 P2，它们各有一个硬件高速缓冲存储器 C1 和 C2，且各<br>
有一个主存储器 M1 和 M2。其性能为：</p>
<table>
<thead>
<tr>
<th></th>
<th>C1</th>
<th>C2</th>
<th>M1</th>
<th>M2</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储容量</td>
<td>4KB</td>
<td>4KB</td>
<td>2MB</td>
<td>2MB</td>
</tr>
<tr>
<td>存取周期</td>
<td>60ns</td>
<td>80ns</td>
<td>1μm</td>
<td>0.9μm</td>
</tr>
</tbody>
</table>
<p>若两台机器指令系统相同，它们的指令执行时间与存储器的平均存取周期成正比。如果在执行某个程序时，所需指令或数据在高速缓冲存储器中存取到的概率 P 是 0.7，试问：<br>
这两台计算机哪个速度快？当 P=0.9 时，处理器的速度哪个快？</p>
<p>（9）某计算机系统提供 24 位虚存空间，主存为 218 字节，采用分页式虚拟存储管理，页面尺寸为 256 字节。假定用户程序产生了虚拟地址 11123456（八进制），假设其对应的块号为 315（八进制），试说明该系统是如何进行地址变换的，相应的物理地址是什么(用八进制表示)？</p>
<p>（9）</p>
<p>虚拟地址11123456 （八进制）转化为二进制为：<br>
001 001 001 010 011 100 101 110<br>
其中前面为页号，而后10 位为位移：001 001 001 010 01-------1 100 101 110 。由于主存大小为218 字节，页面尺寸为256字节=$$2^8$$B ，所以，主存共有256 块。所以，块号为100 （八进制）是合法地址，于是，物理地址为100 （八进制）与位移1 100 101 110 并接，得到：八进制物理地址001000000 1 100 101 110 = = 201456 （八进制）。</p>
<p>（5）</p>
<p>页表长度为 232 = 4 KB；<br>
偏移量为 12 位，页面大小为 $$12^ {12}$$，所以页面数量为 232 / 212 = 220 = 1 M；</p>
<p>（6）</p>
<p>数据在缓存中的比率为:$$(n-1)/n$$</p>
<p>数据在内存中的比率为:$$(1-(n-1)/n)×(m-1)/m=(m-1)/nm$$</p>
<p>数据在辅存中的比率为:$$(1-(n-1)/n)×(1-(m-1)/m)=1/nm$$</p>
<p>故数据平均访问时间是$$=((n-1)/n)×A+((1-(n-1)/n)×(m-1)/m)×(A+B)+( (1-(n-1)/n)×(1-(m-1)/m))×(A+B+C)$$</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mi>A</mi><mo>+</mo><mi>B</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo>+</mo><mi>C</mi><mi mathvariant="normal">/</mi><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">=A+B/n+C/nm
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">/</span><span class="mord mathnormal">nm</span></span></span></span></span></p>
<p>（7）</p>
<p>页表项：$$2^{48}/2^{13 }= 2^{35}$$</p>
<p>反置页表项：$$2^{32}/2^{13} = 2^{19}$$</p>
<p>（8）</p>
<p>CPU平均存取时间为：T=p×T1+(1-p)×T2，T1为高速缓冲存储器存取周期，T2为主存储器存取周期，p为高速缓冲存储器命中率。</p>
<ul>
<li>当p=0.7时，</li>
</ul>
<p>P1平均存取时间为：0.7×60+(1-0.7)×1μs=342ns</p>
<p>P2平均存取时间为：0.7×80+(1-0.7)×0.9μs=326ns</p>
<p>故计算机P2比P1处理速度快</p>
<ul>
<li>当p=0.9时，</li>
</ul>
<p>P1平均存取时间为：0.9×60+(1-0.9)×1μs=154ns</p>
<p>P2平均存取时间为：0.9×80+(1-0.9)×0.9μs=162ns</p>
<p>故计算机P1比P2处理速度快。</p>
<h1>第二次进程作业</h1>
<p>系统有A类临界资源m个，系统有n个进程，每个进程都需要A类临界资源一个，若用信号量S的P、V操作来进行同步，请分析信号量的取值范围。</p>
<ul>
<li>若没有进程使用资源     m</li>
<li>只有一个进程使用</li>
</ul>
<p>有3个进程A、B、C需要循环使用共享的打印机，请给出用信号量和P、V操作实现同步控制的进程描述，并说明信号量的取值范围。</p>
<p>设有4个进程共享一程序段，而每次最多允许两个进程进入该程序段，则信号量的取值范围是多少。</p>
<p>一个快餐厅有4种职员：（1）领班：接受顾客点菜；（2）厨师：准备顾客的饭菜；（3）打包工：将做好的饭菜打包；（4）出纳员－收款并提交食品。每个职员可被看作一个进程，试写出能让四类职员正确并发运行的程序。</p>
<p>三个进程P1、P2、P3互斥使用一个包含N(N&gt;0)个单元的缓冲区，<br>
P1每次用produce()生成一个正整数并用put()送入缓冲区某一空单元中；<br>
P2每次用getodd()从该缓冲区中取出一个奇数并用countodd()统计奇数个数；<br>
P3每次用geteven()从该缓冲区中取出一个偶数并用counteven()统计偶数个数。<br>
请用信号量机制实现这三个进程的同步与互斥活动，并说明所定义的信号量含义。要求用伪代码编写。</p>
<p>1.不会出现，因为可以保证进程并发进入临界区</p>
<ol start="2">
<li></li>
</ol>
<p>将P1中3条语句依次编号为1、2、3；P2中3条语句依次编号为4、5、6。则依次执行1、2、3、4、5、6得到1，依次执行1、2、4、5、6、3得到2，执行4、5、1、2、3、6得到0。</p>
<p>故x的可能值为0,1,2</p>
<p>3.D单处理机中进程是并发进行，不能并行</p>
<p>4.不可能发生的是4，就绪队列中有2个进程且n个进程处于等待状态，这样系统中就有n+2个进程，与题目条件不符合；另外如果没有运行进程且就绪队列非空，处理机不应休闲，而应该调度一个进程来运行，因此错误</p>
<ol>
<li></li>
</ol>
<p>m个资源=信号量初始值； n个进程同时请求m个东西时为m-n</p>
<p>故信号量取值范围为-(n-m)~m</p>
<ol start="2">
<li></li>
</ol>
<p>信号量的取值范围是-2~1</p>
<ol start="3">
<li></li>
</ol>
<p>每次允许2个进程进入，可能出现的情况是：</p>
<p>①没有进程进入；</p>
<p>②有一个进程进入；</p>
<p>③有两个进程进入；</p>
<p>④有两个进程进入并有两个进程等待进入。</p>
<p>对应的信号量值为2、1、0、-2。</p>
<ol start="4">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">semaphore S1,S2,S3,S4;</span><br><span class="line">S1=1;S2=S3=S4=0;</span><br><span class="line">cobegin</span><br><span class="line">&#123;process P1</span><br><span class="line">    begin</span><br><span class="line">	    repeat</span><br><span class="line">		有顾客;</span><br><span class="line">		  P(S1);</span><br><span class="line">		  接受顾客点菜;</span><br><span class="line">		  V(S2);</span><br><span class="line">		  until false;</span><br><span class="line">		end</span><br><span class="line">process P2</span><br><span class="line">    begin</span><br><span class="line">	    repeat</span><br><span class="line">		  P(S2);</span><br><span class="line">		  准备顾客的饭菜;</span><br><span class="line">		  V(S3);</span><br><span class="line">		  until false;</span><br><span class="line">		end</span><br><span class="line">process P3</span><br><span class="line">    begin</span><br><span class="line">	    repeat</span><br><span class="line">		  P(S3);</span><br><span class="line">		  将做好的饭菜打包;</span><br><span class="line">		  V(S4);</span><br><span class="line">		  until false;</span><br><span class="line">		end</span><br><span class="line">process P4</span><br><span class="line">    begin</span><br><span class="line">	    repeat</span><br><span class="line">		  P(S4);</span><br><span class="line">		  收款;</span><br><span class="line">		  V(S1);</span><br><span class="line">		  until false;</span><br><span class="line">		end</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
<ol start="5">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//定义信号量</span><br><span class="line">semaphore  mutex=1；</span><br><span class="line">semaphore odd=0;</span><br><span class="line">semaphore even=0；</span><br><span class="line">//P1、P2和P3共享的缓冲区的空位需要一个</span><br><span class="line">semaphore empty=N；</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">	while(true)&#123;</span><br><span class="line">		p(empty);</span><br><span class="line">		num = produce();</span><br><span class="line">		p(mutex);</span><br><span class="line">		put();</span><br><span class="line">		v(mutex);</span><br><span class="line">		if(num%2 == 0)</span><br><span class="line">			v(even);</span><br><span class="line">		else</span><br><span class="line">			v(odd);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		p(odd);</span><br><span class="line">		p(mutex);</span><br><span class="line">		getodd();</span><br><span class="line">		countodd();</span><br><span class="line">		v(mutex);</span><br><span class="line">		v(empty);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">P3()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		p(even);</span><br><span class="line">		p(mutex);</span><br><span class="line">		geteven();</span><br><span class="line">		counteven();</span><br><span class="line">		v(mutex);</span><br><span class="line">		v(empty);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Apricot</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%8D%E4%B9%A0%E4%B9%A0%E9%A2%98/">http://example.com/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%8D%E4%B9%A0%E4%B9%A0%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">川河杏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/v2-9acbd6f7775df18ce8639dd9639aa47a_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%A8%E5%B1%80%E5%AF%B9%E9%BD%90/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/下载.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">动态规划应用之全局对齐</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/下载.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">层次分析法|评价类模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统进程管理"><img class="cover" src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/v2-9acbd6f7775df18ce8639dd9639aa47a_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">操作系统进程管理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://z3.ax1x.com/2021/09/19/43pFP0.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Apricot</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xingziding"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎！如果你有什么想和我交流的，请直接发送到邮箱2674608132@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.1.</span> <span class="toc-text">第二次作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">第二次进程作业</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/%E8%82%86%E6%84%8F%E7%94%9F%E9%95%BF-02%E6%9C%9F-%E5%90%91%E5%A4%96%E5%A5%94%E8%B5%B0%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/" title="肆意生长|02期-向外奔走的意义是什么"><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/IMG_1901.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="肆意生长|02期-向外奔走的意义是什么"/></a><div class="content"><a class="title" href="/2022/07/25/%E8%82%86%E6%84%8F%E7%94%9F%E9%95%BF-02%E6%9C%9F-%E5%90%91%E5%A4%96%E5%A5%94%E8%B5%B0%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/" title="肆意生长|02期-向外奔走的意义是什么">肆意生长|02期-向外奔走的意义是什么</a><time datetime="2022-07-25T09:18:51.000Z" title="发表于 2022-07-25 17:18:51">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/%E5%BC%80%E5%8D%B7%E3%80%82/" title="开卷。"><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/v2-e5da10c1cabb0eab852afa34d0d52931_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开卷。"/></a><div class="content"><a class="title" href="/2022/07/25/%E5%BC%80%E5%8D%B7%E3%80%82/" title="开卷。">开卷。</a><time datetime="2022-07-25T08:44:33.000Z" title="发表于 2022-07-25 16:44:33">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/%E5%A4%8F%E5%AD%A3%E6%9C%AA%E5%AE%8C%EF%BC%8C%E6%88%91%E8%BF%98%E5%96%9C%E6%AC%A2%E4%BD%A0%E3%80%82/" title="夏季未完，我还喜欢你。"><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/IMG_1818.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="夏季未完，我还喜欢你。"/></a><div class="content"><a class="title" href="/2022/07/25/%E5%A4%8F%E5%AD%A3%E6%9C%AA%E5%AE%8C%EF%BC%8C%E6%88%91%E8%BF%98%E5%96%9C%E6%AC%A2%E4%BD%A0%E3%80%82/" title="夏季未完，我还喜欢你。">夏季未完，我还喜欢你。</a><time datetime="2022-07-25T06:05:18.000Z" title="发表于 2022-07-25 14:05:18">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/18/%E5%BD%B1%E8%AF%84-%E3%80%8A%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88%E3%80%8B%E2%80%94%E2%80%94%E6%88%91%E5%B7%B2%E7%BB%8F%E4%B8%8E%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E6%93%A6%E8%82%A9%E8%80%8C%E8%BF%87%E4%BA%86/" title="影评|《海上钢琴师》——我已经与这个世界擦肩而过了"><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/p2572401438.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="影评|《海上钢琴师》——我已经与这个世界擦肩而过了"/></a><div class="content"><a class="title" href="/2022/07/18/%E5%BD%B1%E8%AF%84-%E3%80%8A%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88%E3%80%8B%E2%80%94%E2%80%94%E6%88%91%E5%B7%B2%E7%BB%8F%E4%B8%8E%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E6%93%A6%E8%82%A9%E8%80%8C%E8%BF%87%E4%BA%86/" title="影评|《海上钢琴师》——我已经与这个世界擦肩而过了">影评|《海上钢琴师》——我已经与这个世界擦肩而过了</a><time datetime="2022-07-18T14:05:57.000Z" title="发表于 2022-07-18 22:05:57">2022-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/18/%E2%80%9C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%90%8E%E6%9C%9F%EF%BC%8C%E4%BD%86%E8%A6%81%E4%BC%9A%E4%BF%AE%E5%9B%BE%E2%80%9D/" title="“可以不后期，但要会修图”"><img src="https://cdn.jsdelivr.net/gh/xingziding/picodemo/img/肖全.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="“可以不后期，但要会修图”"/></a><div class="content"><a class="title" href="/2022/07/18/%E2%80%9C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%90%8E%E6%9C%9F%EF%BC%8C%E4%BD%86%E8%A6%81%E4%BC%9A%E4%BF%AE%E5%9B%BE%E2%80%9D/" title="“可以不后期，但要会修图”">“可以不后期，但要会修图”</a><time datetime="2022-07-18T10:53:23.000Z" title="发表于 2022-07-18 18:53:23">2022-07-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Apricot</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%8D%E4%B9%A0%E4%B9%A0%E9%A2%98/'
    this.page.identifier = '/2022/03/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%8D%E4%B9%A0%E4%B9%A0%E9%A2%98/'
    this.page.title = '操作系统|复习习题'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Twikoo' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="categories/个人博客/">个人博客</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">数学</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="categories/影评/">影评</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">肆意生长</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" href="categories/数学建模/">数学建模</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">个人博客</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" href="categories/肆意生长/">肆意生长</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">影评</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" href="categories/诗词/">诗词</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">诗词</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" href="categories/辩论/">辩论</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">辩论</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/操作系统/">操作系统</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>